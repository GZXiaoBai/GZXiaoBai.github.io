{"pages":[{"title":"博客介绍","text":"自我介绍这是一个正常的少年的博客，来自中国（China）现在还是一名普通的学生，写这个博客主要有两个用处，一个是发布一些技术教程，另一个就是想发一些文章。其实很早就行拥有一个自己的博客了，一直没时间搞，现在就趁机用Hexo搭建了一个博客 爱好：二次元 动漫 搞机 还是希望大家能喜欢这个博客吧， 特别注意本博客的所有文章，未经允许，禁止转载这个还是需要声明一下的，我不希望某些伸手党和盗哥来这里瞎搞，谢谢配合🙏 拒绝白嫖，从我做起每个人都要争做不白嫖的好孩子是不是？因此，希望大家在浏览了我的博客后，能留下足迹👣，发表一下自己的评论和看法👀对了，如果是土豪大佬的话，可以小小的打赏一下，支持一下哦～ 社交QQ：3467365604微信：18268357443Bilibili：https://space.bilibili.com/355276854黑苹果研究社（QQ群）：706372078Github：https://github.com/GZXiaoBai","link":"/about/index.html"},{"title":"友链","text":"kaze0617.gitee.io","link":"/youlian/index.html"}],"posts":[{"title":"Hackintosh安装全攻略","text":"以下内容基本摘自Eternal Qiu的博客，日后准备进行修改链接：https://blog.qiuxiangzhi.top/2019/07/15/macOS-Guide/ 前言我打算写一个教程来引导小白入坑，不在本文介绍那些复杂需要折腾的驱动问题。 警告请注意，本贴只做技术与学习探讨，不做任何商业和违法用途。同时请各位在实践学习后，于24小时内自行消除。 在非苹果设备上安装macOS操作系统需要承担一定责任，希望各位明确用途后，仔细思考。作者不提倡读者进行下面的操作，本贴仅供技术参考。 可能涉及到的法律问题：macOS1014； 如果您是非个人用户或用作商业用途，您应该观看上述材料中所提及问题，并不要接触实施下述操作。 资源准备工作 一台电脑，最好是搭载Windows 7及以上的操作系统，推荐Windows 10； 一个不少于4G的U盘，8GB起步；如果安装macOS10.15（Catalina）请使用16G的U盘。 工具软件（DiskGenius专业版，balenaEtcher官方版，微PE官方版）； 原版镜像（这里提供的是黑果小兵的镜像，侵权删）； 解压工具（此处链接的是7-Zip）； 知道如何百度； 知道如何百度是非常重要的一件事情，因为里面涉及到一些概念，这些概念比较不那么专业，但确实也不是很常见，因此需要有一定的百度能力（主要还是有一些小白太懒了，常见诸如如何进BIOS都不愿意去百度了解）。 电脑调试工作 下载或安装好上述软件，其中DiskGenius专业版最好是免安装版的。 打开DiskGenius专业版，右键自己的磁盘（不是分区），查看是否是GPT分区，若不是，需要在PE下转换。 双击微PE.exe，点击右下角生成.iso文件，解压该iso文件到你的（确保它是Fat 32格式并最好转移其他文件）U盘里。 进入BIOS，找到你的BIOS里面的这几个选项，并将其设置成对应状态。主要有：DVMT-Preallocted（&gt;64MB）,Security Boot（disabled），SATA Mode/磁盘模式（AHCI），UEFI启动（纯），CSM（关闭），启动顺序（U盘第一位），保存重启。 进入微PE，找到自己下载的DiskGenius专业版，双击打开。若硬盘格式是MBR，则将该软件挪到U盘里面，再双击打开。右键有操作系统及想安装macOS的磁盘，将其转换成GPT（GUID）格式。 查看将被安装macOS的磁盘，是否存在一个&gt;200MB的EFI分区。若没有，则可删除所有已存在的MSR分区及EFI分区，此时若磁盘最前部的空闲空间&gt;200MB，则可以直接建立EFI（EFI Partition）分区。若仍少于200MB，则右键磁盘此时的第一分区，选择调整磁盘大小，在前部空间分出200MB大小空闲空间，并新建EFI（EFI Partition）分区。 检查好磁盘均是GPT（GUID）格式、（Windows所在磁盘和macOS将安装的所在磁盘上）存在&gt;200MB的EFI分区，确保好这两点之后，点击PE桌面上的Dism++，选择自己的Windows操作系统，选择引导修复，（一般）无脑下一步即可。 注意事项：转换为GUID格式，会删除该硬盘的扩展分区 电脑准备工作完成。 安装调试过程 打开balenaEtcher，插入U盘，按照提示操作，选择下载好的镜像进行烧录。 烧录好后可以有两种选择，一步一步继续往下走或者直接跳转到第6步，（若下载的镜像为我推荐的则）两种方式都可以完成安装，推荐一步一步走。 在这里找到你的机型或类似配置的EFI，下载备用。若找不到请直接跳第6步操作。 打开DiskGenius软件，将U盘EFI分区内的所有文件删除，并使用Ctrl+V的快捷键方式将下载的EFI文件夹粘贴进去。注意，EFI文件夹下若还有一个EFI文件夹，存在嵌套情况，请直接将最里层的EFI复制进U盘的EFI分区。 检查EFI/CLOVER/ACPI/Patched/，若存在DSDT文件，直接删除。 重启，选择U盘作为第一启动项，选择Boot macOS install from macOS Mojave installation（macOS图标那一项），如果你没有更换原有EFI，接着就是跑代码过程了。如果更换过了EFI，那么在移动到安装项之后，按下空格键，同样空格选择**-v，再ESC回到原有界面**安装即可。 若启动不顺利，碰到直接重启，卡死在某一界面，我的建议是：安装时候进行录像，将卡死或者导致重启的代码截图出来，在群里寻求帮助。当然，我更加推荐前往远景论坛查贴或者直接百度卡死代码解决这些问题。 若一切安装顺利，则它将进入安装界面。在安装界面选择磁盘工具，将预安装分区抹除成HFS分区，也即日志式，若你是固态硬盘，也可选择apfs。磁盘名字自己任意给定，白果磁盘名字为Macintosh HD，尽量避免这个名字。 接下来就可以进行安装了，一路下一步，选择自己刚刚命名的磁盘安装，等待安装完成。 安装完成会重启回到引导界面，此时选择Boot macOS install From 【你自己起的磁盘名字】，空格同样可以选择代码模式。进入第二次安装，此时不需要手动操作，等待安装完成重启即可。 此时回到引导界面应是已经安装完成，选择Boot macOS From 【你自己起的磁盘名字】，进入设置界面，接下来等着你的就是macOS的全新体验了。 macOS、Windows 双引导在安装完成之后，要做的就是进行引导的设置。 有两种设置引导的方式，此处推荐使用的是PE进行引导的建立，也介绍Windows下设置引导的方法介绍。 Windows环境下完成引导的设置。 在Windows下设置引导需要借助软件完成，软件名称及官网下载[在这里](https://www.easyuefi.com/index-us.html)。该软件我们需要的是企业版，普通版本没有添加引导的功能，注意甄别。 下载完软件后，先打开DiskGenius，将U盘里面的ESP（EFI）分区中Clover文件夹整个复制到桌面。再通过Ctrl+V的方式，粘贴在Windows启动磁盘的ESP分区中EFI文件夹下。 （Windows、macOS在不同磁盘下时）也可以复制整个EFI文件夹到macOS所在磁盘的ESP分区。新手小白建议前述操作。 接下来打开easyUEFI，选择新建引导项，引导类型选择“Linux或其他”，名称只能输入英文，可随意填写。选择你所放引导的ESP分区，找到Clover文件夹下的CLOVERX64.efi文件，选中完成即可。 注意事项：如果未看到CLOVER.efi文件（EasyUEFI下），请重启电脑即可看到 PE下完成引导的设置。 进入PE，然后同样，打开DiskGenius，将**U盘里面的ESP（EFI）分区中Clover**文件夹整个复制到桌面。再**通过Ctrl+V**的方式，粘贴在**Windows启动磁盘的ESP分区中EFI文件夹**下。 （Windows、macOS在不同磁盘下时）也可以复制整个EFI文件夹到macOS所在磁盘的ESP分区。新手小白建议前述操作。 此处的引导建立使用Bootice这款软件，选择引导，UEFI设置。引导文件同样选择CLOVERX64.efi，名称随意，选择粘贴了引导文件的分区。 安装过程常见问题解答 抹除时出现“磁盘空间不足，无法完成操作”怎么办？ ``答：这是你在电脑调试阶段中，给ESP分区空间预留不足200MB，需要重新操作，将空间扩大`。 怎么才知道我的磁盘是不是GPT格式呢？` 答：当你在DiskGenius专业版软件中，右键该磁盘时，若“转换到GUID格式”为**灰色不可选中**，则表示该磁盘格式为GPT。 为什么我在安装的时候找不到我的硬盘？ 答：若为三星的PM981或者PM981a，或者其他的出名不可安装macOS（百度可以知道是否难以安装）的硬盘，建议小白放弃。愿意折腾的话可以查看这篇我的[**PM981安装教程**](http://bbs.pcbeta.com/viewthread-1814806-1-1.html)（发布在远景），不保证在所有机型上稳定。若不是上述硬盘，则我建议更新clover版本，对小白最简单的方式是，更换镜像版本或者镜像源。 BIOS设置时找不到一模一样的选项怎么办？ 答：并不是所有的BIOS都有我所提到的选项名称，这很正常。你需要找到意思相近的名称项，设置好就可以。如有的BIOS将**Security Boot**叫做**Security/安全启动**，名称变化很正常。**只有DVMT Pre-allocated项**，大部分笔记本BIOS会选择隐藏，可以不用纠结。其余选项都应存在你的BIOS中，并需要设置好。 安装时，-v滚代码卡apfs_moudle_start怎么办（一般是10.15的问题） 答：打补丁如下Comment Find*[HEX] Replace[HEX]**change EC0 to EC 4543305f 45435f5f**change H_EC to EC 485f4543 45435f5fchange ECDV to EC 45434456 45435f5f 一般只需选第一条加粗补丁即可 安装10.15时，卡VoodooPS2Controller怎么办(一般是10.15的问题) 到EFI/CLOVER/kexts/others/目录下，删除VoodooPS2Controller.kexts 其他我希望各位小白，在明确步骤后，可以通过自己百度、找帖子之后解决掉大部分问题，之后才是找大神寻求帮助。 我比较推荐以下方式问问题： 这个我应该怎么做？Not 大神帮我搞定！ 这个在哪里有具体操作？Not 大神帮我搞定！ 帮完忙，比较喜欢这种回复： 我知道了，谢谢你！Not 好/嗯/哦。 如果希望别人帮你安装，自己不想动手不想研究的话，希望你还是左转淘宝或者别接触黑苹果以及玩黑果的人，白嫖可耻，时间宝贵。 感谢感谢QQ群：706372078里的群主Eternal Qiu本人QQ：3467365604","link":"/2020/05/16/Hackintosh%E5%AE%89%E8%A3%85%E5%85%A8%E6%94%BB%E7%95%A5/"},{"title":"Mac个性化和美化","text":"前言Mac这一高端大气上档次的系统，其中一点就是十分简洁美观，那我这次就教大家如何让自己的Mac独特一些。 准备你需要准备以下软件： PlistEdit Pro（用于修改文字） ThemeEngine（用于修改图标） 我这里也提供软件下载： 百度网盘 密码: gtu4 修改我们需要修改的只有3个文件。 有关图标：Assets.car 路径：/System/Applications/Utilities/System Information.app/Contents/Resources/Assets.car 有关文字：SPInfo.strings 路径：/System/Applications/Utilities/System Information.app/Contents/Resources/zh_CN.lproj/SPInfo.string ​ SPInfoSystemView.strings 路径：/System/Applications/Utilities/System Information.app/Contents/Resources/zh_CN.lproj/SPInfoSystemView.string 修改就很简单了，用ThemeEngine打开Assets，在左边的导航栏找到Systemlogo","link":"/2020/06/20/Mac%E4%B8%AA%E6%80%A7%E5%8C%96%E5%92%8C%E7%BE%8E%E5%8C%96/"},{"title":"macOS下的QQ和微信小助手","text":"QQ小助手 3.3 中文版 (QQ消息防撤回及抢红包神器)QQ小助手 是一款 Mac QQ消息防撤回以及 Mac QQ 抢红包插件，还可以设置自动回复规则以及抢红包规则（抢红包群过滤以及红包关键字过滤）。Mac QQ抢红包支持群和个人红包，包括文字口令红包。 安装 QQ小助手下载完成后打开【安装步骤】，按所示步骤进行安装与卸载。 需要注意的是，此插件会修改QQ程序，因为Apple的规则设置，只要程序被修改就会导致签名验证不完整，如果出现打不开的&gt;情况请关闭SIP或者刷新本网页后查看右上角的解决方法。 下载城通网盘：https://sn9.us/file/19991453-411102272 微信小助手 2.5.7 中文版 (微信消息防撤回及微信多开)微信小助手 for Mac是一款mac微信消息防撤回、禁止微信更新、微信多开、微信窗口置顶、微信免认证登录、禁用微信内置浏览器多功能集于一体的工具集。 安装微信小助手双击【安装.command】即可自动完成微信小助手的安装。 下载蓝奏云：点击下载城通网盘：https://t00y.com/file/19991453-442175047","link":"/2020/05/23/QQ%E5%92%8C%E5%BE%AE%E4%BF%A1%E5%B0%8F%E5%8A%A9%E6%89%8B/"},{"title":"如何简单的编译OpenCore","text":"1、编译之前，请确保电脑里安装了 Command Line Tools，安装方法： 终端执行：sudo xcode-select –install如果因为一些不可抗力出现下载失败的问题，请尝试去苹果官网手动下载安装。 P.S.安装过 Xcode 的朋友无需安装 Command Line Tools；同时安装过正式版和 Beta 版 Xcode 的朋友，可以通过如下命令选择目标 Tools，如果没有请忽略本条。在终端执行：sudo xcode-select -s /Applications/Xcode-beta.app/Contents/Developer 2、编译最新版 OC：终端执行：cd /Users/你的用户名/Desktop/终端执行：git clone https://github.com/acidanthera/**OpenCore**Pkg.git终端执行：cd OpenCorePkg终端执行：./macbuild.tool 然后等待一大串的东西，选YES就行！等待编译完就好。 最后去路径 OpenCorePkg/UDK/Build/OpenCorePkg/RELEASE_XCODE5/X64/ 路径拷贝 OpenCore-x.x.x-RELEASE.zip 至桌面备用。 3、编译所需 efi 文件： 步骤跟上面一样 终端执行：cd /Users/你的用户名/Desktop/终端执行：git clone https://github.com/acidanthera/AppleSupportPkg.git终端执行：cd AppleSupportPkg终端执行：./macbuild.tool 4、到此为止，我们得到如下两个文件： 解压 OpenCore-x.x.x-RELEASE 获取 BOOT、OC 文件夹。解压 AppleSupport-x.x.x-RELEASE.zip 获得所需 efi 文件。","link":"/2020/05/16/%E5%A6%82%E4%BD%95%E7%AE%80%E5%8D%95%E7%9A%84%E7%BC%96%E8%AF%91OpenCore/"},{"title":"疯狂即是美丽-物语系列","text":"物语系列介绍《物语系列》是由日本轻小说作家西尾维新创作、中国台湾插画家VOFAN（本名戴源亨）负责插画的轻小说系列，分为First Season、Second Season、Final Season、Off Season和Monster Season五季。 作品以21世纪初的日本直江津镇为舞台，描述一名高中少年阿良良木历与少女们遇到许多日本民间传说的怪谭故事。本作品跟一般怪谭故事不同，不以击退妖怪或寻找事发原因之类的解谜作为主线。作品主要透过对话，为男主角和少女们之间的内心作深刻描写。西尾维新以其特有的“话痨”风格，将大量的对话和心理描写穿插到主线事件中，同时还加入了许多后设以及对社会和其他作品的讽刺。故事之中既有恋爱喜剧，又有热血的动作描写，可见作者把想要的东西都写进作品中去。所以，作者将“物语系列”自评本作为他的自信作，亦称之为“以很难媒体化为目的而写的小说”。 中文名：物语系列原版名称：〈物語〉シリーズ作者：西尾维新(日本)地区：日本类型：轻小说 作品背景《物语系列》中的《化物语（上·下）》、《伤物语》、《伪物语（上·下）》和《猫物语（黑）》是该系列的第一部，从《猫物语（白）》到《恋物语》是第二部，而从《凭物语》开始则是最终部。其中，《猫物语（黑）》和《猫物语（白）》虽然都以《猫物语》为书名，但却是各自独立的作品，而且两本的第一人称叙述者都不同。 《化物语》中的《黑仪·重蟹》、《真宵·蜗牛》、《骏河·猴子》三章最早在讲谈社旗下的文学杂志《Mephisto（メフィスト）》2005年9月号~2006年5月号上刊载 ，《终物语（上）》中的第1章《扇·公式》则在漫画杂志《别册少年Magazine》2013年10月号将先行刊载 。 故事时间轴顺序 参考上图即可 动漫播出顺序与时间轴顺序不同！ 动画播出顺序 化物语 伪物语 猫物语黑 猫物语白 倾物语 囮物语 鬼物语 恋物语 花物语 凭物语 终物语 历物语 伤物语 终物语 下 这里还是推荐按动画播出顺序看，当然伤物语你可以提前看，比如放在化物语或者伪物语之前 短评这真的是很优秀的一部作品。庞大的文本，清奇的作画。这是青春的物语，影射的正是生活本身，我们的生活是一个属于自己的“物语” 人只有自己才能拯救自己 资源分享百度云链接：https://pan.baidu.com/s/1n_E-pcOmDfkfiWxQbDxWzQ提取码：lpyj","link":"/2020/05/23/%E7%96%AF%E7%8B%82%E5%8D%B3%E6%98%AF%E7%BE%8E%E4%B8%BD-%E7%89%A9%E8%AF%AD%E7%B3%BB%E5%88%97/"},{"title":"计算Slide解决内存报错","text":"前言如果你在安装黑苹果的过程中，遇到了内存报错，那么你可能需要通过计算Slide值并注入来解决这个问题 **KASLR (Kernel Address Space Layout Randomization)**：内核地址空间布局随机化，是 macOS 所使用的一项内存管理技术，它会在内存基址上加一个 Slide 值，用于保护内核安全。 Slide 的有效范围是 8 - 255，转化为 16 进制就是 8 - FF ，乘 200000（16 进制）得出的内存基址 Start 范围为 1000000 - 1FE00000 问题如果你遇到如下代码，在安装过程中。 1Error allocating 0x0x116F6 pages at 0x00000000093eb000 alloc type 2 那么恭喜，这是内存报错，对于笔记本而言，一般可以通过更换内存补丁来解决。但对于自由度较高的台式机来说，就没那么好了，那么我们就来计算Slide值，启用KASLR内存管理技术了。 解决方案我们继续看上面的那一串代码，我们需要记录的就是0x0x116F6，也就是Page值 进入 clover，打开 UEFI Shell 64 界面，输入 memmap -b，找到第一个 Start 大于 1000000（对应 Slide 最小值 8）且 Page 值大于 0x116F6 （出错的 Page 值） 的 Available 类型数据，如下所示 1Available 00000000 1000B000 00000000 5F04FFFF 00000000 0004F045 00000000 0000000F 可见 1000B000 在这个范围内，使用十六进制计算器用这个值除 200000（16 进制）得出的值转为十进制向上取整即可 例如 例如 1000B000（十六进制）/ 200000（十六进制）= 128.02（十进制）向上取整为 129，接下来我们将 slide=129 添加到引导参数中，问题基本上都能解决 在线十六进制计算器：点我！ 参考教程XStar-Dev’s Blog","link":"/2020/06/06/%E8%AE%A1%E7%AE%97Slide%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E6%8A%A5%E9%94%99/"},{"title":"黑苹果论坛必备App-一个集成热门论坛app","text":"前言这是你迈上黑苹果之路的方向引导！ 软件分享链接: https://pan.baidu.com/s/1yWI5Agap32pbb2lqxYSriQ 密码: 77vh 感谢感谢**@仙女plus(软件作者),同时仙女也是OpenCOre霓虹灯主题**的作者，希望大家多多这次一下哈！","link":"/2020/08/11/%E9%BB%91%E8%8B%B9%E6%9E%9C%E8%AE%BA%E5%9D%9B%E5%BF%85%E5%A4%87App-%E4%B8%80%E4%B8%AA%E9%9B%86%E6%88%90%E7%83%AD%E9%97%A8%E8%AE%BA%E5%9D%9Bapp/"},{"title":"为小白设计的电池教程（DSDT）","text":"为小白设计的电池教程（DSDT） 编写者：G.Z.小白 这个教程会尽量写的简单，只要你认真，你绝对看得懂！此教程整理，修改，借鉴于：http://bbs.pcbeta.com/viewthread-1751487-1-1.html对其进行了完善，以及一些有问题的地方进行了修改。 初步了解实现原理 : 由于苹果无法使用ACPI EC中超过8位的寄存器（又叫EC缓冲区，Embedded Controller Buffer），我们需要利用Hotpatch的原理更名涉及到EC的Method使其失效并在新建的SSDT补丁中重新定义它们，使macOS能够通过SMC电池驱动正确识别电池EC信息。 好了，我觉得你应该得有个可以用的DSDT吧，如果没有请去提取自己的DSDT并反编译，排好错。具体见群文件的教程。首先打开我们的DSDT，搜索（Command + F）Embeddedcontrol OperationRegion名称，此为EC操作区的名称，一般名称为ERAM、ECF2、ECF3、ECOR等，并且有的机器可能不止一个 好了现在，我们找到了这里，仔细观察，发现它在EC0控制器下，具体路径是_SB.PCI0.LPCB.EC0。当然每个人的可能不一样，最后的EC0，还可能是ECDV、EC、H_EC。这里我们主要关注Field里的东西，就是那一堆四个字母的东西。在这一堆东西中，我们只要注意8位以上的就行（就是右边的数字）。因为电池驱动无法处理8位以上的字节，所以就需要我们手动来处理来。我们需要用到的工具：计算器（Mac自带），Maciasl，新建一个txt文件。 打开txt文件，我们先把一下代码复制进去（我会把这个做成样例放在群文件）处理方法补丁如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485# created by GZxioabai# add method B1B2 into method label B1B2 remove_entry;into definitionblock code_regex . insertbeginMethod (B1B2, 2, NotSerialized)\\n{\\nReturn(Or(Arg0, ShiftLeft(Arg1, 8)))\\n}\\nend; # add method B1B4into method label B1B4 remove_entry;into definitionblock code_regex . insertbeginMethod (B1B4, 4, NotSerialized)\\n{\\n Store(Arg3, Local0)\\n Or(Arg2, ShiftLeft(Local0, 8), Local0)\\n Or(Arg1, ShiftLeft(Local0, 8), Local0)\\n Or(Arg0, ShiftLeft(Local0, 8), Local0)\\n Return(Local0)\\n}\\nend;# add utility methods to read/write buffers from/to \\_SB.PCI0.LPCB.EC0into method label RE1B parent_label \\_SB.PCI0.LPCB.EC0 remove_entry;into method label RECB parent_label \\_SB.PCI0.LPCB.EC0 remove_entry;into Device label EC0 insertbeginMethod (RE1B, 1, NotSerialized)\\n{\\n OperationRegion(ERAM, EmbeddedControl, Arg0, 1)\\n Field(ERAM, ByteAcc, NoLock, Preserve) { BYTE, 8 }\\n Return(BYTE)\\n}\\nMethod (RECB, 2, Serialized)\\n// Arg0 - offset in bytes from zero-based \\_SB.PCI0.LPCB.EC0\\n// Arg1 - size of buffer in bits\\n{\\n ShiftRight(Arg1, 3, Arg1)\\n Name(TEMP, Buffer(Arg1) { })\\n Add(Arg0, Arg1, Arg1)\\n Store(0, Local0)\\n While (LLess(Arg0, Arg1))\\n {\\n Store(RE1B(Arg0), Index(TEMP, Local0))\\n Increment(Arg0)\\n Increment(Local0)\\n }\\n Return(TEMP)\\n}\\nend;into method label WE1B parent_label \\_SB.PCI0.LPCB.EC0 remove_entry;into method label WECB parent_label \\_SB.PCI0.LPCB.EC0 remove_entry;into Device label EC0 insertbeginMethod (WE1B, 2, NotSerialized)\\n{\\n OperationRegion(ERAM, EmbeddedControl, Arg0, 1)\\n Field(ERAM, ByteAcc, NoLock, Preserve) { BYTE, 8 }\\n Store(Arg1, BYTE)\\n}\\nMethod (WECB, 3, Serialized)\\n// Arg0 - offset in bytes from zero-based EC\\n// Arg1 - size of buffer in bits\\n// Arg2 - value to write\\n{\\n ShiftRight(Arg1, 3, Arg1)\\n Name(TEMP, Buffer(Arg1) { })\\n Store(Arg2, TEMP)\\n Add(Arg0, Arg1, Arg1)\\n Store(0, Local0)\\n While (LLess(Arg0, Arg1))\\n {\\n WE1B(Arg0, DerefOf(Index(TEMP, Local0)))\\n Increment(Arg0)\\n Increment(Local0)\\n }\\n}\\nend; 以上的这些东西是同用的处理方法，包括B1B2（16字节处理），B1B4（32字节处理），WECB和RECB（这两个是处理32字节以上的） 16位处理方法接下来，我们来讲讲16位如何处理。 比如我们在Field下找到的这个16位的BADC，我们需要将它拆分掉，拆成来两个8字节，这样就能被电池驱动处理了。 读取操作： 我们还是先来解释一下吧，什么是读取什么是写入？在DSDT中常见的是下面两种语句。第一种语句（老）： Store（BADC，ENC0） 在这里，Store语句中，BADC是读的操作，而ENC0是写的操作，解释一下，就是将BADC写入到ENC0，所以你可几个口诀就是“左读右写 第二种语句（新）： ENC0 = BADC 在这里，就刚好相反了，这里没有了Store，但意思还是将BADC写入到ENC0，所以BADC还是读，ENC0还是写。 写入操作： Store（FB4，BADC） 在这里，Store语句中，FB4是读的操作，而BADC是写的操作，解释一下，就是将BADC写入到ENC0，所以你可几个口诀就是“左读右写” 那么其实很好理解了BADC = FB4这个就跟上面提到的反一下了解了这些那么你可以继续接下来的拆分工作了。 Field（声明字段）下处理补丁：into Device label EC0 code_regex BADC,\\s+16, replace_matched begin DCA0,8,DCA1,8, end; 我们先来理解一下这个， into：针对 Device label：关于这个设备范围里 EC0:设备的名称 code_regex：匹配搜索 BADC,\\s+16：被搜索的代码，\\s+16表示16字节 replace_matched：匹配替换 begin DCA0,8,DCA1,8, end：从什么什么开始，到什么什么结束，这里的意思就是，用于替换的是“DCA0,8,DCA1,8, ” 那么整句话的意思就是， 在设备EC0的范围内搜索16字节的BADC，如果有，就替换为“DCA0,8,DCA1,8,” 我们在来表示成一个处理结果：BADC， 16，-----&gt;DCA0,8,DCA1,8,当然这只是在声明字段中进行拆分处理，我们还要在BADC被调用的地方进行处理。我们首先需要查找一下BADC在哪些地方被调用。（重要提醒：没被调用的其实不需要拆分！意思是你根本不用去管它！） 被调用的字段（一般在Method下）那里，对字段进行拆分：读的处理补丁：into method label SMTF code_regex BADC replaceall_matched begin B1B2(DCA0,DCA1) end; 解释： into method label SMTF：针对Method为SMTF的这个范围内 code_regex ：匹配（搜索） BADC：被搜索的字段 replace_matched：替换匹配 begin B1B2(DCA0,DCA1) end：这是被替换的内容 那么总的意思就是， 在method为SMTF这个范围里面，搜索“BADC,\\s+16”, ，如果有，就把它替换为“DCA0,8,DCA1,8,” 。 那么最后的处理结果是： 未处理前： 1234567891011121314Method (SMTF, 1, NotSerialized){ If (LEqual (Arg0, Zero)) { Return (BADC) } If (LEqual (Arg0, One)) { Return (Zero) } Return (Zero)} 打了补丁之后： 1234567891011121314Method (SMTF, 1, NotSerialized){ If (LEqual (Arg0, Zero)) { Return (B1B2 (DCA0, DCA1)) } If (LEqual (Arg0, One)) { Return (Zero) } Return (Zero)} 当然啦，这仅仅是BADC如果是读取的时候的处理，那要是碰到写入的时候，我们就要像下面这样处理，不能使用B1B2的方法了比如：Store (Arg0, BADC) （BADC是16位的情况）需要改为：Store (ShiftRight(Arg0,8),DCA1) （DCA1是16位拆分后的第二个）Store (Arg0,DCA0) （DCA0是16位拆分后的第一个）那么补丁，我们就可以这样写： into method label SMRW code_regex Store\\s\\(Arg3,\\sBADC\\) replaceall_matched begin Store(ShiftRight(Arg3,8),DCA1)\\nStore(Arg3, DCA0) end;** 其中这段文字中的\\s代表的是一个空格，\\n代表的是换行，也就是回车，主要的是在搜索那里，需要注意符号转义，在任何符号前都要加一个反斜杠转义，也就是加一个\\ 那最后的处理结果是：未处理： 1Store (Arg0, BADC) 打了补丁后： 12Store (ShiftRight(Arg0,8),DCA1)Store (Arg0,DCA0) 32字节处理方法32位字段的处理方法其实跟16位一样，用到的是B1B4，区别就是，16位拆除2个，32拆除4个在Field里查找32位的，这里我们也是举一个例子，比如B1CH 补丁如下：into Device label EC0 code_regex B1CH,\\s+16, replace_matched begin CH10,8,CH11,8,CH12,CH13 end;处理结果为：B1CH,32, ---—&gt; BC0H,8,BC1H,8,BC2H,8,BC3H,8,我们可以发现，这个跟16位的差不多，就是后面多拆2个，那就不用多废话解释了。我们直接讲在被调用的地方的处理（32字节基本不会有写入操作，也从未出现过）补丁如下：into method label _BIF code_regex B1CH replaceall_matched begin B1B4(CH10,CH11,CH12,CH13) end;那这个也就不解释了，差不多的意思。其中B1B4是32位处理方法处理结果：未处理： 1234Method (_BIF, 0, NotSerialized){ Store (B1CH, IFCH) //未处理前} 打了补丁后： 1234Method (_BIF, 0, NotSerialized){ Store (B1B4 (BC0H, BC1H, BC2H, BC3H), IFCH) //把被调用B1CH两处拆分为4个字节} 偏移量计算到了32位以上的字段处理，我们会使用到RECB（读）和WECB（写）两个处理方法我先给你看两个例子：RECB(0x98, 64)WECB (0x1C, 256, FB4)我们来解释一下它们的组成部分，RECB(偏移量, 字段长度)，WECB(偏移量, 字段长度,未处理前的前参数 )字段长度很好理解，64位就是64，128位就是128，256位就是256WECB中的未处理前的前参数，我们举个例子好理解一点比如：Store (FB4, SMD0)SMD0是256位的需要处理的字段，在这里是写入，那么它的前参数，顾名思义就是前面那个FB4那么其实，最主要的问题是偏移量了。举例1： 1234567891011121314Offset (0x04), （基地址）CMCM, 8, //0x04CMD1, 8, //0x05CMD2, 8, //0x06CMD3, 8, //0x07Offset (0x18),Offset (0x19), （基地址）SMST, 8, //0x19MBMN, 80, //0x1AMBPN, 96, //0x24GPB1, 8, //0x30GPB2, 8, //0x31 GPB3, 8, //0x32 GPB4, 8, //0x33 我们看这里的，MBMN是需要处理的80位字段，它的偏移量的计算就要涉及到它上面的基地址，我们看到了那个基地址是0x19，我们还可以发现它前面有个8位的SMST，我们将8除以8，得到1，再把0x19加上这个1，最后得到了0x1A，那么下面那个MBPN的偏移量怎么算呢，就是将前面的都加起来除以8，再加上基地址，就是8加上80得到88，除以8，等于11，转换为16进制就是B，0x19加上B，等于0x24.（注意的是，在除以8后的数字，一定要转换为16进制，再加上基地址！）举例二： 1234567891011121314151617181920Offset (0x53), //（基地址） B0TP, 16, // 从基地址起 ，为0x53 B0VL, 16, //16，为2个字节； 计算：上一个的起始地址0x53+0x2（上一个的16位占了2个字节，10转为16进制为0x2）值为0x55B0CR, 16, //16，为2个字节； 计算：上一个的起始地址0x55+0x2（上一个的16位占了2个字节，10转为16进制为0x2）值为0x57B0AC, 16, //16，为2个字节； 计算：上一个的起始地址0x57+0x2（上一个的16位占了2个字节，10转为16进制为0x2）值为0x59B0ME, 16, //16，为2个字节； 计算：上一个的起始地址0x59+0x2（上一个的16位占了2个字节，10转为16进制为0x2）值为0x5bB0RS, 16, //16，为2个字节； 计算：上一个的起始地址0x5b+0x2（上一个的16位占了2个字节，10转为16进制为0x2）值为0x5dB0RC, 16, //16，为2个字节； 计算：上一个的起始地址0x5d+0x2（上一个的16位占了2个字节，10转为16进制为0x2）值为0x5fB0FC, 16, //16，为2个字节； 计算：上一个的起始地址0x5f+0x2（上一个的16位占了2个字节，10转为16进制为0x2）值为0x61B0MC, 16, //16，为2个字节； 计算：上一个的起始地址0x61+0x2（上一个的16位占了2个字节，10转为16进制为0x2）值为0x63B0MV, 16, //16，为2个字节； 计算：上一个的起始地址0x63+0x2（上一个的16位占了2个字节，10转为16进制为0x2）值为0x65B0ST, 16, //16，为2个字节； 计算：上一个的起始地址0x65+0x2（上一个的16位占了2个字节，10转为16进制为0x2）值为0x67B0CC, 16, //16，为2个字节； 计算：上一个的起始地址0x67+0x2（上一个的16位占了2个字节，10转为16进制为0x2）值为0x69B0DC, 16, //16，为2个字节； 计算：上一个的起始地址0x69+0x2（上一个的16位占了2个字节，10转为16进制为0x2）值为0x6bB0DV, 16, //16，为2个字节； 计算：上一个的起始地址0x6b+0x2（上一个的16位占了2个字节，10转为16进制为0x2）值为0x6dB0SI, 16, //16，为2个字节； 计算：上一个的起始地址0x6d+0x2（上一个的16位占了2个字节，10转为16进制为0x2）值为0x6fB0SN, 32, //32，为4个字节； 计算：上一个的起始地址0x6f+0x2（上一个的16位占了2个字节，10转为16进制为0x2）值为0x71 B0MN, 96, //96，为12个字节 计算：上一个的起始地址0x71+0x4（上一个的32位占了4个字节，10转为16进制为0x4）值为0x75B0DN, 64, // 64，为8个字节；计算：上一个的起始地址0x75+0xc（上一个的96位占了12个字节，10转为16进制为0xc）值为0x81B0CM, 48, // 计算：上一个的起始地址0x81+0x8（64位占了8个字节，10转为16进制为0x8）值为0x89 这里我就不说明了，自己看右边的注释理解一下吧。举例3： 12345678910Offset (0x5D), //（基地址） ENIB, 16, // 16，为2个字节； 从基地址起 ，为0x5DENDD, 8, //8，为1个字节； 计算：上一个的起始地址0x5D+0x2（上一个的16位占了2个字节，10转为16进制为0x2）值为0x5FSMPR, 8, //8，为1个字节； 计算：上一个的起始地址0x5F+0x1（上一个的8位占了1个字节，10转为16进制为0x1）值为0x60SMST, 8, //8，为1个字节； 计算：上一个的起始地址0x60+0x1（上一个的8位占了1个字节，10转为16进制为0x1）值为0x61SMAD, 8, //8，为1个字节； 计算：上一个的起始地址0x61+0x1（上一个的8位占了1个字节，10转为16进制为0x1）值为0x62SMCM, 8, //8，为1个字节； 计算：上一个的起始地址0x62+0x1（上一个的8位占了1个字节，10转为16进制为0x1）值为0x63SMD0, 256, //256，为32个字节； 计算：上一个的起始地址0x63+0x1（上一个的8位占了1个字节，10转为16进制为0x1）值为0x64BCNT, 8, //8，为1个字节； 计算：上一个的起始地址0x64+0x20（上一个的256位占了32个字节，10转为16进制为0x20）值为0x84SMAA, 24, //8，为1个字节； 计算：上一个的起始地址0x84+0x1（上一个的8位占了1个字节，10转为16进制为0x1）值为0x85 举例4 最为简单： 1234567891011121314151617181920212223Field (ERAM, ByteAcc, NoLock, Preserve) { Offset (0x04), FLD0, 64 // 64，为8个字节； 从基地址起 ，为0x04（偏移量） }Field (ERAM, ByteAcc, NoLock, Preserve) { Offset (0x04), FLD1, 128 // 128，为16个字节； 从基地址起 ，为0x04（偏移量） }Field (ERAM, ByteAcc, NoLock, Preserve) { Offset (0x04), FLD2, 192 // 192，为24个字节； 从基地址起 ，为0x04（偏移量） }Field (ERAM, ByteAcc, NoLock, Preserve) { Offset (0x04), FLD3, 256 // 256，为32个字节； 从基地址起 ，为0x04（偏移量） } 举例五 特殊： 123456789101112131415161718OperationRegion (SMBX, EmbeddedControl, 0x18, 0x28) //第三个值是起始地址Field (SMBX, ByteAcc, NoLock, Preserve){ PRTC, 8, //8，为1个字节； 上面第三个值是起始地址0x18 SSTS, 5, //计算：上一个的起始地址0x18+0x1（上一个的8位占了1个字节，10转为16进制为0x1）值为0x19 , 1, ALFG, 1, CDFG, 1, //上面 5+1+1+1才凑够8位（1字节） ADDR, 8, //8，为1个字节；计算：上一个的起始地址0x19+0x1（上面 5+1+1+1才凑够8位占了1个字节，10转为16进制为0x1）值为0x19 0x1A CMDB, 8, //8，为1个字节； 计算：上一个的起始地址0x1A+0x1（上一个的8位占了1个字节，10转为16进制为0x1）值为0x1B BDAT, 256, //256，为32个字节；计算：上一个的起始地址0x1B+0x1（上一个的8位占了1个字节，10转为16进制为0x1）值为0x1C BCNT, 8, , 1, ALAD, 7, ALD0, 8, ALD1, 8} 32位以上字段的处理（包括64，128，256等）在Field下，我们需要对其进行重命名使其失效。补丁如下： into Device label EC0 code_regex (SMD0,)\\s+(256) replace_matched begin SMDX,%2,//%1%2 end; 这里需要注意的是要打括号！，还有后面的SMDX是重命名后的结果，**%2,//%1%2**这个也是要加上的！接下来在被调用的地方进行处理： 读取调用 Store (SMD0, FB4)我们要用到RECB，补丁如下： into method label MHPF code_regex SMD0 replaceall_matched begin RECB(0x1C, 256) end;处理结果为：Store (SMD0, FB4) —&gt; Store (RECB (0x1C, 0x0100), FB4) 写入调用 Store (FB4, SMD0)我们要用到WECB，补丁如下： into method label MHPF code_regex Store\\s\\(FB4,\\sSMD0\\) replaceall_matched begin WECB(0x1C,256,FB4) end； 值得注意的是，我们这边是将整个Store语句进行了替换，这也是WECB处理的不同之处。处理结果：Store (FB4, SMD0) —&gt; WECB (0x1C, 256, FB4) Mutex确认，最后检查确保DSDT里的Mutex都是0x00，不然可能会出现电量显示0%的情况。在DSDT里搜索Mutex，如果有的不是0x00，你就自己手动改成0x00。 补充当电池有时能正常显示电量，有时不能会出现一个小叉，则可能是多个电池的位置导致的，如图有两个位置，分别为“BAT0”和“BAT1”，我们需要禁用掉“BAT1”这个位置，以达到正常读取电量","link":"/2020/05/16/%E4%B8%BA%E5%B0%8F%E7%99%BD%E8%AE%BE%E8%AE%A1%E7%9A%84%E7%94%B5%E6%B1%A0%E6%95%99%E7%A8%8B%EF%BC%88DSDT%EF%BC%89/"},{"title":"进阶：电池热补丁（Battery-Hotpatch）之路","text":"前言在有了OpenCore的引导后，已经不在推荐使用DSDT了，况且，现在也是主要推广热补丁（HotPatch），热补丁具有比DSDT更好的灵活性，于是便开始写这篇文章了。 准备步骤首先，我们需要下载我提供的电池热补丁的样本（SSDT-BATT.dsl)。同时，我还准备了联想X260的电池热补丁作为例子。链接如下：百度云 密码:fn1v然后，准备你的DSDT或者SSDT（存储有EC缓冲区的，Embedded Controller Buffer） 需要工具：Hackintool，Maciasl，科学计算器（Mac自带） 要求：最好有一定的电池的基础知识，详细看见我之前写的电池DSDT的教程 初步动作打开热补丁样本，我们来进行一些修改。（按照我自己的习惯来的） 我们要修改的有三处：1.DefinitionBlock的修改，将这里的ACDT改为自己DSDT开头DefinitionBlock里的第三项2.DefinitionBlock的修改，将最后的数值也改成自己DSDT里的3.External引用路径里的EC路径，改成自己DSDT里的实际路径 这里我们有一处要修改：1.Scope路径下，改为自己DSDT里的实际路径 16位和32位的处理这里的处理，其实与DSDT里的差不多。我们先将Field复制到SSDT里 像我这样复制下来，里面到内容不复制。注意⚠️：你不难发现，我这里有许多的Field，那是因为X260的DSDT里，就是像这样的分散的Field。因此，当你制作电池热补丁时，搜索EmbeddedControllerBuffer找到Field后，记得同时搜索Field的名称，比如，ECOR，看看有没有分散在其它地方的 复制过来后，我们需要将Field进行改名，比如，ECOR，我改为了ECOX，这样就不会与原ACPI里的发生冲突。 热补丁与DSDT的拆分不同，我们直接将需要拆分的，拆好放到SSDT中，我们创建的Field下。 123456789101112131415161718192021222324252627282930313233343536373839404142OperationRegion (ECOX, EmbeddedControl, Zero, 0x0100)Field (ECOX, ByteAcc, NoLock, Preserve){ Offset (0xA0), RCB0, 8, RCB1, 8, FCB0, 8, FCB1, 8, Offset (0xA8), ACB0, 8, ACB1, 8, VOB0, 8, VOB1, 8}Field (ECOX, ByteAcc, NoLock, Preserve){ Offset (0xA0), BMB0, 8, BMB1, 8}Field (ECOX, ByteAcc, NoLock, Preserve){ Offset (0xA0), DCB0, 8, DCB1, 8, DVB0, 8, DVB1, 8, Offset (0xAA), SNB0, 8, SNB1, 8}Field (ECOX, ByteAcc, NoLock, Preserve){ Offset (0xA0), CHB0, 8, CHB1, 8, CHB2, 8, CHB3, 8} 最后的结果就如上所示，正确拆分，正确计算偏移量。（这些都包含在我DSDT的教程中） 接着我们在DSDT中搜索需要被拆分的字节，找到所在的Method，记下路径，然后在SSDT里，添加这个路径。比如我们，发现GBIF这个Method里面有需要拆分的自己，观察所得，GBIF所在的路径为： _SB.PCI0.LPC.EC 那么我们就在SSDT中加上这个Scope： 123Scope (\\_SB.PCI0.LPC.EC){} 然后，我们将GBIF这一整个Method复制到这个路径下，在对字节进行拆分。（以此类推，其它Method也是这么处理） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171Method (GBIF, 3, NotSerialized){ If (_OSI (&quot;Darwin&quot;)) { Acquire (BATM, 0xFFFF) If (Arg2) { Or (Arg0, One, HIID) Store (B1B2 (BMB0, BMB1), Local7) ShiftRight (Local7, 0x0F, Local7) XOr (Local7, One, Index (Arg1, Zero)) Store (Arg0, HIID) If (Local7) { Multiply (B1B2 (FCB0, FCB1), 0x0A, Local1) } Else { Store (B1B2 (FCB0, FCB1), Local1) } Store (Local1, Index (Arg1, 0x02)) Or (Arg0, 0x02, HIID) If (Local7) { Multiply (B1B2 (DCB0, DCB1), 0x0A, Local0) } Else { Store (B1B2 (DCB0, DCB1), Local0) } Store (Local0, Index (Arg1, One)) Divide (Local1, 0x14, Local2, Index (Arg1, 0x05)) If (Local7) { Store (0xC8, Index (Arg1, 0x06)) } ElseIf (B1B2 (DVB0, DVB1)) { Divide (0x00030D40, B1B2 (DVB0, DVB1), Local2, Index (Arg1, 0x06)) } Else { Store (Zero, Index (Arg1, 0x06)) } Store (B1B2 (DVB0, DVB1), Index (Arg1, 0x04)) Store (B1B2 (SNB0, SNB1), Local0) Name (SERN, Buffer (0x06) { &quot; &quot; }) Store (0x04, Local2) While (Local0) { Divide (Local0, 0x0A, Local1, Local0) Add (Local1, 0x30, Index (SERN, Local2)) Decrement (Local2) } Store (SERN, Index (Arg1, 0x0A)) Or (Arg0, 0x06, HIID) Store (RECB (0xA0, 0x80), Index (Arg1, 0x09)) Or (Arg0, 0x04, HIID) Name (BTYP, Buffer (0x05) { 0x00, 0x00, 0x00, 0x00, 0x00 }) Store (B1B4 (CHB0, CHB1, CHB2, CHB3), BTYP) Store (BTYP, Index (Arg1, 0x0B)) Or (Arg0, 0x05, HIID) Store (RECB (0xA0, 0x80), Index (Arg1, 0x0C)) } Else { Store (0xFFFFFFFF, Index (Arg1, One)) Store (Zero, Index (Arg1, 0x05)) Store (Zero, Index (Arg1, 0x06)) Store (0xFFFFFFFF, Index (Arg1, 0x02)) } Release (BATM) Return (Arg1) } Else { Return (XBIF (Arg0, Arg1, Arg2)) }}Method (GBST, 4, NotSerialized){ If (_OSI (&quot;Darwin&quot;)) { Acquire (BATM, 0xFFFF) If (And (Arg1, 0x20)) { Store (0x02, Local0) } ElseIf (And (Arg1, 0x40)) { Store (One, Local0) } Else { Store (Zero, Local0) } If (And (Arg1, 0x07)){} Else { Or (Local0, 0x04, Local0) } If (LEqual (And (Arg1, 0x07), 0x07)) { Store (0x04, Local0) Store (Zero, Local1) Store (Zero, Local2) Store (Zero, Local3) } Else { Store (Arg0, HIID) Store (B1B2 (VOB0, VOB1), Local3) If (Arg2) { Multiply (B1B2 (RCB0, RCB1), 0x0A, Local2) } Else { Store (B1B2 (RCB0, RCB1), Local2) } Store (B1B2 (ACB0, ACB1), Local1) If (LGreaterEqual (Local1, 0x8000)) { If (And (Local0, One)) { Subtract (0x00010000, Local1, Local1) } Else { Store (Zero, Local1) } } ElseIf (LNot (And (Local0, 0x02))) { Store (Zero, Local1) } If (Arg2) { Multiply (Local3, Local1, Local1) Divide (Local1, 0x03E8, Local7, Local1) } } Store (Local0, Index (Arg3, Zero)) Store (Local1, Index (Arg3, One)) Store (Local2, Index (Arg3, 0x02)) Store (Local3, Index (Arg3, 0x03)) Release (BATM) Return (Arg3) } Else { Return (XBST (Arg0, Arg1, Arg2, Arg3)) }} 如上所示，即为最后的处理结果。 32位以上字节的处理步骤基本相同，也是搜索所需修改字节对应对Method，然后找到对应路径，添加到SSDT中。32位以上的，不需要Field下的更改，只需要改Method，进行RECB和WECB的处理 详细见DSDT教程中。 以下为完整处理结果（其实也在上文Method的GBIF，GBST中）（包含了全部） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244Scope (\\_SB.PCI0.LPC.EC){ Method (RE1B, 1, NotSerialized) { OperationRegion (ERM2, EmbeddedControl, Arg0, One) Field (ERM2, ByteAcc, NoLock, Preserve) { BYTE, 8 } Return (BYTE) } Method (RECB, 2, Serialized) { ShiftRight (Add (Arg1, 0x07), 0x03, Arg1) Name (TEMP, Buffer (Arg1){}) Add (Arg1, Arg0, Arg1) Store (Zero, Local0) While (LLess (Arg0, Arg1)) { Store (RE1B (Arg0), Index (TEMP, Local0)) Increment (Arg0) Increment (Local0) } Return (TEMP) } OperationRegion (ECOX, EmbeddedControl, Zero, 0x0100) Field (ECOX, ByteAcc, NoLock, Preserve) { Offset (0xA0), RCB0, 8, RCB1, 8, FCB0, 8, FCB1, 8, Offset (0xA8), ACB0, 8, ACB1, 8, VOB0, 8, VOB1, 8 } Field (ECOX, ByteAcc, NoLock, Preserve) { Offset (0xA0), BMB0, 8, BMB1, 8 } Field (ECOX, ByteAcc, NoLock, Preserve) { Offset (0xA0), DCB0, 8, DCB1, 8, DVB0, 8, DVB1, 8, Offset (0xAA), SNB0, 8, SNB1, 8 } Field (ECOX, ByteAcc, NoLock, Preserve) { Offset (0xA0), CHB0, 8, CHB1, 8, CHB2, 8, CHB3, 8 } Method (GBIF, 3, NotSerialized) { If (_OSI (&quot;Darwin&quot;)) { Acquire (BATM, 0xFFFF) If (Arg2) { Or (Arg0, One, HIID) Store (B1B2 (BMB0, BMB1), Local7) ShiftRight (Local7, 0x0F, Local7) XOr (Local7, One, Index (Arg1, Zero)) Store (Arg0, HIID) If (Local7) { Multiply (B1B2 (FCB0, FCB1), 0x0A, Local1) } Else { Store (B1B2 (FCB0, FCB1), Local1) } Store (Local1, Index (Arg1, 0x02)) Or (Arg0, 0x02, HIID) If (Local7) { Multiply (B1B2 (DCB0, DCB1), 0x0A, Local0) } Else { Store (B1B2 (DCB0, DCB1), Local0) } Store (Local0, Index (Arg1, One)) Divide (Local1, 0x14, Local2, Index (Arg1, 0x05)) If (Local7) { Store (0xC8, Index (Arg1, 0x06)) } ElseIf (B1B2 (DVB0, DVB1)) { Divide (0x00030D40, B1B2 (DVB0, DVB1), Local2, Index (Arg1, 0x06)) } Else { Store (Zero, Index (Arg1, 0x06)) } Store (B1B2 (DVB0, DVB1), Index (Arg1, 0x04)) Store (B1B2 (SNB0, SNB1), Local0) Name (SERN, Buffer (0x06) { &quot; &quot; }) Store (0x04, Local2) While (Local0) { Divide (Local0, 0x0A, Local1, Local0) Add (Local1, 0x30, Index (SERN, Local2)) Decrement (Local2) } Store (SERN, Index (Arg1, 0x0A)) Or (Arg0, 0x06, HIID) Store (RECB (0xA0, 0x80), Index (Arg1, 0x09)) Or (Arg0, 0x04, HIID) Name (BTYP, Buffer (0x05) { 0x00, 0x00, 0x00, 0x00, 0x00 }) Store (B1B4 (CHB0, CHB1, CHB2, CHB3), BTYP) Store (BTYP, Index (Arg1, 0x0B)) Or (Arg0, 0x05, HIID) Store (RECB (0xA0, 0x80), Index (Arg1, 0x0C)) } Else { Store (0xFFFFFFFF, Index (Arg1, One)) Store (Zero, Index (Arg1, 0x05)) Store (Zero, Index (Arg1, 0x06)) Store (0xFFFFFFFF, Index (Arg1, 0x02)) } Release (BATM) Return (Arg1) } Else { Return (XBIF (Arg0, Arg1, Arg2)) } } Method (GBST, 4, NotSerialized) { If (_OSI (&quot;Darwin&quot;)) { Acquire (BATM, 0xFFFF) If (And (Arg1, 0x20)) { Store (0x02, Local0) } ElseIf (And (Arg1, 0x40)) { Store (One, Local0) } Else { Store (Zero, Local0) } If (And (Arg1, 0x07)){} Else { Or (Local0, 0x04, Local0) } If (LEqual (And (Arg1, 0x07), 0x07)) { Store (0x04, Local0) Store (Zero, Local1) Store (Zero, Local2) Store (Zero, Local3) } Else { Store (Arg0, HIID) Store (B1B2 (VOB0, VOB1), Local3) If (Arg2) { Multiply (B1B2 (RCB0, RCB1), 0x0A, Local2) } Else { Store (B1B2 (RCB0, RCB1), Local2) } Store (B1B2 (ACB0, ACB1), Local1) If (LGreaterEqual (Local1, 0x8000)) { If (And (Local0, One)) { Subtract (0x00010000, Local1, Local1) } Else { Store (Zero, Local1) } } ElseIf (LNot (And (Local0, 0x02))) { Store (Zero, Local1) } If (Arg2) { Multiply (Local3, Local1, Local1) Divide (Local1, 0x03E8, Local7, Local1) } } Store (Local0, Index (Arg3, Zero)) Store (Local1, Index (Arg3, One)) Store (Local2, Index (Arg3, 0x02)) Store (Local3, Index (Arg3, 0x03)) Release (BATM) Return (Arg3) } Else { Return (XBST (Arg0, Arg1, Arg2, Arg3)) } }} 可以对照给出的X260的热补丁看看 排错，补充引用声明完成这些步骤后，点击编译会发现错误 这些都是因为没有被定义，因此我们需要进行引用，来排除这些错误。以BATM为例，在DSDT中进行搜索，找到它被定义的路径和类型，写成External External (_SB.PCI0.LPC.EC_BATM, MutexObj) 前者为路径，后者为类型 更多详见如下： 以下摘自iStar的博客：Device：原始 ACPI 定义示例 1234Scope (_SB.PCI0.LPCB){ Device (H_EC) { 补丁中添加的代码示例 1External (_SB_.PCI0.LPCB.H_EC, DeviceObj) Method：原始 ACPI 定义示例 1Method (_STA, 0, NotSerialized) /* _STA: Status */ 补丁中添加的代码示例 1External (_SB_.BAT0._STA, MethodObj) Mutex：原始 ACPI 定义示例 1Mutex (BATM, 0x07) 补丁中添加的代码示例 1External (_SB_.PCI0.LPCB.H_EC.BATM, MutexObj) FieldUnit：原始 ACPI 定义示例 123456Field(...){...BCNT, 8,...} 补丁中添加的代码示例 1External (_SB_.PCI0.LPCB.H_EC.BCNT, FieldUnitObj) Integer：原始 ACPI 定义示例 1Name (ECA2, Zero) 补丁中添加的代码示例 1External (_SB_.PCI0.LPCB.H_EC.ECA2, IntObj) Package：原始 ACPI 定义示例 12345678910111213141516Name (PBIF, Package (0x0D){ One, 0xFFFFFFFF, 0xFFFFFFFF, One, 0xFFFFFFFF, 0xFA, 0x96, 0x0A, 0x19, &quot;BAT0&quot;, &quot; &quot;, &quot; &quot;, &quot; &quot;}) 补丁中添加的代码示例 1External (_SB_.BAT0.PBIF, PkgObj) 添加if判断语句为了让自己修改的Method不会影响Windows系统，我们需要添加if判断语句，明确它的内容作用在哪个系统。 如，在GBIF这个Method的第一个括号下加入If (_OSI (“Darwin”)) 1234567 Method (GBIF, 3, NotSerialized) { If (_OSI (&quot;Darwin&quot;)) { Acquire (BATM, 0xFFFF) If (Arg2)..... 然后，我们去到这个Method的尾部，看看这个Method，最后有没有返回（Return）很显然这个GBIF有的，就是Return (Arg1)对于有返回语句的，我们需要在Else下加上Return，没有则不需要。 Else部分自己加在Method末尾。 最终结果如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990Method (GBIF, 3, NotSerialized){ If (_OSI (&quot;Darwin&quot;)) { Acquire (BATM, 0xFFFF) If (Arg2) { Or (Arg0, One, HIID) Store (B1B2 (BMB0, BMB1), Local7) ShiftRight (Local7, 0x0F, Local7) XOr (Local7, One, Index (Arg1, Zero)) Store (Arg0, HIID) If (Local7) { Multiply (B1B2 (FCB0, FCB1), 0x0A, Local1) } Else { Store (B1B2 (FCB0, FCB1), Local1) } Store (Local1, Index (Arg1, 0x02)) Or (Arg0, 0x02, HIID) If (Local7) { Multiply (B1B2 (DCB0, DCB1), 0x0A, Local0) } Else { Store (B1B2 (DCB0, DCB1), Local0) } Store (Local0, Index (Arg1, One)) Divide (Local1, 0x14, Local2, Index (Arg1, 0x05)) If (Local7) { Store (0xC8, Index (Arg1, 0x06)) } ElseIf (B1B2 (DVB0, DVB1)) { Divide (0x00030D40, B1B2 (DVB0, DVB1), Local2, Index (Arg1, 0x06)) } Else { Store (Zero, Index (Arg1, 0x06)) } Store (B1B2 (DVB0, DVB1), Index (Arg1, 0x04)) Store (B1B2 (SNB0, SNB1), Local0) Name (SERN, Buffer (0x06) { &quot; &quot; }) Store (0x04, Local2) While (Local0) { Divide (Local0, 0x0A, Local1, Local0) Add (Local1, 0x30, Index (SERN, Local2)) Decrement (Local2) } Store (SERN, Index (Arg1, 0x0A)) Or (Arg0, 0x06, HIID) Store (RECB (0xA0, 0x80), Index (Arg1, 0x09)) Or (Arg0, 0x04, HIID) Name (BTYP, Buffer (0x05) { 0x00, 0x00, 0x00, 0x00, 0x00 }) Store (B1B4 (CHB0, CHB1, CHB2, CHB3), BTYP) Store (BTYP, Index (Arg1, 0x0B)) Or (Arg0, 0x05, HIID) Store (RECB (0xA0, 0x80), Index (Arg1, 0x0C)) } Else { Store (0xFFFFFFFF, Index (Arg1, One)) Store (Zero, Index (Arg1, 0x05)) Store (Zero, Index (Arg1, 0x06)) Store (0xFFFFFFFF, Index (Arg1, 0x02)) } Release (BATM) Return (Arg1) } Else { Return (XBIF (Arg0, Arg1, Arg2)) }} 我们发现，我将GBIF在Else中重命名为了XBIF，这需要与后面config里添加重命名对应。那么，你们可能会有疑问，这个Arg0这些是这么来的？这个需要观察： 1Method (GBIF, 3, NotSerialized) 就是中间这个数字得来的，3的话就是在XBIF后面的括号里填写，Arg0， Arg1， Arg2。是多少，你就从Arg0开始往后一个个按顺序加。0就不填，留空。 添加完了这些后，你再编译，发现报错了，然后一样，补充引用声明。如， 1External (_SB.PCI0.LPC.EC.XBIF, MethodObj) 这样就可以了。 重命名与Mutex检查最后，我们来进行重命名和Mutex检查比如GBIF，我们来重命名为XBIF，这样就不会与ACPI中的GBIF冲突了规则如下：Comment：BAT GBIF to XBIF利用Hackintool，将GBIF转换为16进制为：47424946我们再补上两位，这两位就需要看Method了 1Method (GBIF, 3, NotSerialized) NotSerialized代表0，Serialized代表8我们将其相加，中间的数字+N或SGBIF就是：3+0=3，3转换为16进制就是3那么最后的两位就是03 XBIF的16进制为：58424946 完整的如下：Comment：BAT GBIF to XBIFFind：47424946 03Replace：58424946 03 GBST的就是：Method (GBST, 4, NotSerialized) Comment：BAT GBST to XBSTFind：47425354 04Replace：58425354 04 把这些重命名加到Config里。 你需要检查Mutex，确保他们全部为0 在当前使用的DSDT文件里搜索Mutex，看出现的几个变量是否为0，目前所知道的绝大多数机器的ACPI Mutex都是默认置0的，但是对于一些联想机器，它们往往有几个Mutex初始值并不是0，这里我们利用ACPI二进制更名的方法实现置0 以Mutex (BATM, 0x07)为例，先转换BATM为十六进制代码，得到 42 41 54 4D 在前后加上完整定义的十六进制代码，01代表Mutex，07则代表默认值，最终得到 01 42 41 54 4D 07 我们的目的是使Mutex对象置0，所以config的更名应填 Comment Set Mutex BATM, 0x07 to 0x0Find 01 42 41 54 4D 07Repalce 01 42 41 54 4D 00其它Mutex对象按照同样的方法处理即可 这样下来你的电池热补丁就基本制作完毕了，对于双电池系统的电池（实际只有一块电池的），我们需要禁用其中一个。 双电池系统，屏蔽其中一个比如，你的DSDT中有BAT0或BAT1两个电池设备，但你实际只在用其中一个。那么，你先看看另一个是否开启，如果另一个也是开启的，你需要屏蔽它。 参考我给的SSDT-BAT0-Disable-X260.aml 将DefinitionBlock框出来的位置，改成自己的，同时修改External和Scope为自己所要屏蔽的电池设备的路径。 然后保存即可。 然后我们要对所屏蔽电池设备下的_STA进行更名： CLOVER：处理比较简单，将所需屏蔽的电池设备，转换为16进制，比如BAT1（42415430）Comment：BAT _STA to XSTA in BAT1Find：5F535441Replace：58535441TgtBridge：42415431 OC：OpenCore因为没有TgtBridge，因此处理比较麻烦1.选择使用skip，count：Skip为跳过，就看你所要更改的_STA上有几个一样的_STA就跳过几个，count是替换次数，填1次即可Comment：BAT _STA to XSTA in BAT1Find：5F535441Replace：58535441Skip:（填跳过的次数）Count：1 到这里，你已经做好一个电池热补丁和屏蔽补丁了，然后再加上ACPIBatteryManager.kext或者SMCBatteryManager.kext，不出问题，你就可以看到你可爱的电池图标了！","link":"/2020/05/16/%E8%BF%9B%E9%98%B6%EF%BC%9A%E7%94%B5%E6%B1%A0%E7%83%AD%E8%A1%A5%E4%B8%81%EF%BC%88Battery-Hotpatch%EF%BC%89%E4%B9%8B%E8%B7%AF/"},{"title":"用热补丁修理你的触摸板（TouchPad-Hotpatch）","text":"前言当你的触摸板无法正常工作时，或者一点也不工作时，那你可能就需要修改ACPI来修补修补你的触摸板来，使其能够正常工作。毕竟一台笔记本电脑，用不了触摸板实在是太难受了。（如果你有钱买妙控板，那就另当别论了） 确定设备路径1.进入Windows系统，打开设备管理器，找到人体输入学设备，确认自己是不是I2C触摸板（有可能是I2C USB），如果找不到I2C HID设备，下面的鼠标又没有PS2的时候，把每个都打开看看有没有Bios Device Name 里有 I2C 的。 2.然后右键查看属性，在详细信息里找到触摸板的位置路径 像这里的路径就是：_SB.PCI0.I2C0.TPD0我们把它记下来吧，之后会用到。 确定APIC PIn继续在Windows下，设备管理器中确认一下你的APIC Pin，到如图所示位置： 在这个地方我们也能找到需要的APIC Pin。 声明：如果这里括号里的值大于等于 1024（10进制），直接去做热补丁，删掉所有有关操作系统的判断就好了 你也可以在Mac下查看APIC Pin 到Mac系统下，使用IORegistryExplorer查看APIC Pin在右上角搜索自己的触摸板名称，比如根据我们之前照出来的路径，触摸板设备的名称就为TPD0 那么我们为什么需要知道APIC Pin呢？因为APIC Pin可以帮助你判断你的触摸板的工作状态，如果你的Pin小于2F那么你的触摸板在macOS就是APIC中断模式的，你可以理解为“半免躯模式”了，几乎不需要做什么修改就能够比较好的驱动。当然，这是极少数的情况。 大部分人应该都是大于2F的，因此触摸板会是GPIO中断模式，但因为在macOS下绝大部分人的GPIO中断模式无法直接驱动，才需要制作热补丁来使其正常工作。 归纳一下就是：Pin &lt; 2F** 或者 **无IOInterruptSpecifiers**，为**APIC****Pin &gt; 2F 需要制作热补丁使触摸板在GPIO模式下正常工作 APIC中断，GPIO中断与轮询这里我们稍微了解一下触摸板工作的三个模式： APIC中断：上文有提到，也就是最好的一个工作模式，当然只有极少数人有这个运气是APIC中断 GPIO中断：Windows系统下用的也是这个模式，是仅次于APIC中断的，比较高效，也是我们首先推荐的模式。触摸板热补丁也是主要针对GPIO中断有比较多的修改。 轮询：最低效的一个模式，但相比GPIO中断，这个模式的适用范围更广，大部分机子都能适用这个，虽然有时候可能有些问题，如，指针漂移或者不灵敏等，但却更容易驱动。GPIO中断无法使用的情况下，我们就选择使用轮询模式。 总结归纳：效率：APIC中断 &gt; GPIO中断 &gt; 轮询驱动难易成度：GPIO中断 &gt; 轮询 ，这里APIC中断不作讨论，看你运气。 触摸板热补丁制作在这个板块，我会教你如何去做触摸板热补丁(Hotpatch)，包括GPIO中断和轮询两个模式的制作教程。我也会给出一个案例用于讲解，此案例请不要拿去直接用(没有人会那么傻吧)。 首先我们用Maciasl打开DSDT，并新建一个文件。然后我们将DSDT的DefinitionBlock部分复制到新建的文件中,并将其中的DSDT的字符串改为SSDT，如图： 然后我们根据之前确定的触摸板设备路径(_SB.PCI0.I2C0.TPD0)找到我们需要修改的设备(Device)。很简单，我们按Option + F在搜索框中输入自己触摸板的名称，我们这里的是TPD0，然后回车搜索，找到位于**_SB.PCI0.I2C0下的TPD0**设备。如图： 然后我们在新建的SSDT中，先添加路径Scope(_SB.PCI0.I2C0)，然后将整个TPD0设备复制进去(一定要注意对应括号，不要复制错了)，如图： 然后我们将TPD0进行改名，改成TPXX或者其他的什么都可以，只要不与DSDT中其他的设备名称相同有冲突。我们在新建的SSDT中查找TPD0，并将所有找到的TPD0，都改成TPXX(或者自己改的名称)。 改名前： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245DefinitionBlock (&quot;&quot;, &quot;SSDT&quot;, 2, &quot;DELL &quot;, &quot;CBX3 &quot;, 0x01072009){ Scope (_SB.PCI0.I2C0) { Device (TPD0) { Name (HID2, Zero) Name (SBFB, ResourceTemplate () { I2cSerialBusV2 (0x0000, ControllerInitiated, 0x00061A80, AddressingMode7Bit, &quot;NULL&quot;, 0x00, ResourceConsumer, _Y38, Exclusive, ) }) Name (SBFG, ResourceTemplate () { GpioInt (Level, ActiveLow, ExclusiveAndWake, PullDefault, 0x0000, &quot;\\\\_SB.PCI0.GPI0&quot;, 0x00, ResourceConsumer, , ) { // Pin list 0x0000 } }) Name (SBFI, ResourceTemplate () { Interrupt (ResourceConsumer, Level, ActiveLow, ExclusiveAndWake, ,, _Y39) { 0x00000000, } }) CreateWordField (SBFB, \\_SB.PCI0.I2C0.TPD0._Y38._ADR, BADR) // _ADR: Address CreateDWordField (SBFB, \\_SB.PCI0.I2C0.TPD0._Y38._SPE, SPED) // _SPE: Speed CreateWordField (SBFG, 0x17, INT1) CreateDWordField (SBFI, \\_SB.PCI0.I2C0.TPD0._Y39._INT, INT2) // _INT: Interrupts Method (GTID, 1, Serialized) { If (Arg0) { Switch (CBID) { Case (0x0896) { Return (&quot;DELL0896&quot;) } Case (0x0895) { Return (&quot;DELL0895&quot;) } Case (0x0894) { Return (&quot;DELL0894&quot;) } Case (0x08A5) { Return (&quot;DELL08A5&quot;) } Case (0x08A6) { Return (&quot;DELL08A6&quot;) } Case (0x089C) { Return (&quot;DELL089C&quot;) } Case (0x089D) { Return (&quot;DELL089D&quot;) } Case (0x089E) { Return (&quot;DELL089E&quot;) } Case (0x089F) { Return (&quot;DELL089F&quot;) } Case (0x08A7) { Return (&quot;DELL08A7&quot;) } Case (0x08A8) { Return (&quot;DELL08A8&quot;) } Case (0x08A9) { Return (&quot;DELL08A9&quot;) } Case (0x08BC) { Return (&quot;DELL08BC&quot;) } Case (0x08BD) { Return (&quot;DELL08BD&quot;) } Case (0x08C0) { Return (&quot;DELL08C0&quot;) } Case (0x0949) { Return (&quot;DELL0949&quot;) } Default { Return (&quot;DELL0949&quot;) } } } Else { Return (0x20) } } Method (_INI, 0, Serialized) // _INI: Initialize { If ((OSYS &lt; 0x07DC)) { SRXO (GPDI, One) } INT1 = GNUM (GPDI) INT2 = INUM (GPDI) If ((TPDM == Zero)) { SHPO (GPDI, One) } If ((TPDT == One)) { _HID = &quot;SYNA2393&quot; HID2 = 0x20 Return (Zero) } If ((TPDT == 0x02)) { _HID = &quot;06CB2846&quot; HID2 = 0x20 Return (Zero) } If ((TPDT == 0x06)) { _HID = &quot;ALPS0000&quot; HID2 = 0x20 BADR = 0x2C Return (Zero) } If ((TPDT == 0x05)) { _HID = GTID (One) HID2 = TPDH /* \\TPDH */ Switch (CBID) { Case (0x08BC) { BADR = 0x15 } Case (0x08BD) { BADR = TPDB /* \\TPDB */ } Case (0x08C0) { BADR = TPDB /* \\TPDB */ } Default { BADR = TPDB /* \\TPDB */ } } If ((TPDS == Zero)) { SPED = 0x000186A0 } If ((TPDS == One)) { SPED = 0x00061A80 } If ((TPDS == 0x02)) { SPED = 0x000F4240 } Return (Zero) } } Name (_HID, &quot;XXXX0000&quot;) // _HID: Hardware ID Name (_CID, &quot;PNP0C50&quot; /* HID Protocol Device (I2C bus) */) // _CID: Compatible ID Name (_S0W, 0x03) // _S0W: S0 Device Wake State Method (_DSM, 4, Serialized) // _DSM: Device-Specific Method { If ((Arg0 == HIDG)) { Return (HIDD (Arg0, Arg1, Arg2, Arg3, HID2)) } If ((Arg0 == TP7G)) { Return (TP7D (Arg0, Arg1, Arg2, Arg3, SBFB, SBFG)) } Return (Buffer (One) { 0x00 // . }) } Method (_STA, 0, NotSerialized) // _STA: Status { If (((TPDT != Zero) &amp;&amp; (I2CN &amp; One))) { Return (0x0F) } Return (Zero) } Method (_CRS, 0, NotSerialized) // _CRS: Current Resource Settings { If ((OSYS &lt; 0x07DC)) { Return (SBFI) /* \\_SB_.PCI0.I2C0.TPD0.SBFI */ } If ((TPDM == Zero)) { Return (ConcatenateResTemplate (I2CM (I2CX, BADR, SPED), SBFG)) } Return (ConcatenateResTemplate (I2CM (I2CX, BADR, SPED), SBFI)) } } }} 改名后： 123456789101112131415161718DefinitionBlock (&quot;&quot;, &quot;SSDT&quot;, 2, &quot;DELL &quot;, &quot;CBX3 &quot;, 0x01072009){ Scope (_SB.PCI0.I2C0) { Device (TPXX) //这里将TPD0改为了TPXX { ······ CreateWordField (SBFB, \\_SB.PCI0.I2C0.TPXX._Y38._ADR, BADR) // 这里将TPD0改为了TPXX CreateDWordField (SBFB, \\_SB.PCI0.I2C0.TPXX._Y38._SPE, SPED) // 这里将TPD0改为了TPXX CreateWordField (SBFG, 0x17, INT1) CreateDWordField (SBFI, \\_SB.PCI0.I2C0.TPXX._Y39._INT, INT2) // 这里将TPD0改为了TPXX ······ //没有改动的地方就没有列出来了 } }} 其实我们不难发现，其实也就Device和CreateWordField那里需要改。 然后我们注意到Method (_CRS, 0, NotSerialized)，我们需要对他进行修改，我们看到这里有许多判断语句，其实我们只需要一句Return (ConcatenateResTemplate (XXXX, XXXX))，其它都可以删除掉。当然，如果你的**_CRS里面还有些赋值语句或者其他的一些语句，不只有If判断语句的话，那么就不要乱删**了，以防出现问题。 修正 TPXX 内容： 所有 TPD0 替换为 TPXX。 补丁中 _STA 部分替换为： 1234567891011Method (_STA, 0, NotSerialized){ If (_OSI (&quot;Darwin&quot;)) { Return (0x0F) } Else { Return (Zero) }} 查找 SDS1 (禁止 TPD0 时用到的变量)，将原 If (SDS1...) 修改为 If (one)。 查找 OSYS，删除（注释掉）以下内容： 1234//If (LLess (OSYS, 0x07DC))//{// SRXO (GPDI, One)//} 注：OSYS 小于 0x07DC 时，I2C 设备不工作（0x07DC代表 Windows8）。 GPIO中断实现这里建议您先实现了轮询模式，再来移植中断 实现GPIO中断，我们需要做如下修改。 首先，我们先来讲解一些触摸板的相关内容。我们可以在触摸板设备中找到如下，GpioInt（GPIO中断）、Interrupt（APIC中断） 。 先看SBFI，这个用来实现APIC中断的，当这个值无效的时候（也就是APIC Pin大于2F的时候），走的是轮询 123456789······ Name (SBFI, ResourceTemplate () { Interrupt (ResourceConsumer, Level, ActiveLow, ExclusiveAndWake, ,, _Y39) { 0x00000000, } })······ 我们再来看SBFB，这个轮询和中断都可以调用。当然也有的**_CSR里面不返回这个，而是返回了&gt;I2CM，其实两者的用处是一样的，但I2CM里面包括了更多的东西。我们可以这样理解吧，I2CM**&gt;=SBFB 123456789······ Name (SBFB, ResourceTemplate () { I2cSerialBusV2 (0x0000, ControllerInitiated, 0x00061A80, AddressingMode7Bit, &quot;NULL&quot;, 0x00, ResourceConsumer, _Y38, Exclusive, ) })······ 这里有一个重点，那就是SBFG，其实我们看的不是SBFG这个名字，而是里面的GpioInt，这是中断所需要的。 1234567891011······ Name (SBFG, ResourceTemplate () { GpioInt (Level, ActiveLow, ExclusiveAndWake, PullDefault, 0x0000, &quot;\\\\_SB.PCI0.GPI0&quot;, 0x00, ResourceConsumer, , ) { // Pin list 0x0000 } })······ 讲解完了这些，我们就正式开始动手进行修改吧。 补全缺少的内容。如果你发现你没有GpioInt，那么你就复制下面那段代码到自己建立的触摸板设备(TPXX)中。 1234567891011······ Name (SBFG, ResourceTemplate () { GpioInt (Level, ActiveLow, ExclusiveAndWake, PullDefault, 0x0000, &quot;\\\\_SB.PCI0.GPI0&quot;, 0x00, ResourceConsumer, , ) { // Pin list 0x0000 } })······ 大部分人都是会有GpioInt的，所以一般不需要这个步骤，没有的人不仅需要补上，而且需要计算GPIO Pin。所以说，有这个GpioInt的，是不需要去算GPIO Pin的，它自己会自动注入的，当然你想去算一个Gpio Pin也没事，不影响。 计算GPIO Pin(可选择，见上面第1步的说明)。计算这个Pin的时候，我们需要用到刚开始我们记录的APIC Pin(我之前记录的ACPI Pin是0x33)。我们需要将APIC Pin转换为10进制，0x33转换过来就是51，然后我们把APICPIN = 51代入以下公式\b\b\b\b这里我们要根据不同的处理器选择， Skylake： 123456If APICPIN &gt; 47 And APICPIN &lt;= 79 Then GPIOPIN = APICPIN - 24 GPIOPIN2 = APICPIN + 72 ElseIf APICPIN &gt; 79 And APICPIN &lt;= 119 Then GPIOPIN = APICPIN - 24End If CoffeeLake-H： 123456789101112If APICPIN &gt; 47 And APICPIN &lt;= 71 Then GPIOPIN = APICPIN - 16 GPIOPIN2 = APICPIN + 240 If APICPIN &gt; 47 And APICPIN &lt;= 59 Then GPIOPIN3 = APICPIN + 304 ElseIf APICPIN &gt; 71 And APICPIN &lt;= 95 Then GPIOPIN = APICPIN - 8 GPIOPIN3 = APICPIN + 152 GPIOPIN2 = APICPIN + 120 ElseIf APICPIN &gt; 95 And APICPIN &lt;= 119 Then GPIOPIN = APICPIN If APICPIN &gt; 108 And APICPIN &lt;= 115 Then GPIOPIN2 = APICPIN + 20 End If CoffeeLake-LF和Whiskylake： 12345678910If APICPIN &gt; 47 And APICPIN &lt;= 71 Then GPIOPIN = APICPIN - 16 GPIOPIN2 = APICPIN + 80 ElseIf APICPIN &gt; 71 And APICPIN &lt;= 95 Then GPIOPIN2 = APICPIN + 184 GPIOPIN = APICPIN + 88 ElseIf APICPIN &gt; 95 And APICPIN &lt;= 119 Then GPIOPIN = APICPIN If APICPIN &gt; 108 And APICPIN &lt;= 115 Then GPIOPIN2 = APICPIN - 44 End If 最后，我们会得出GPIOPIN的10进制，我们将其再转为16进制即可。 不过在某些极端状况下，你找到的值都不起作用的话。那么此时，你只能去尝试些比较常见的数值了，如0x17、0x1b、0x34和0x55。（仅限 SunrisePoint） 计算好了就把GPIO Pin填入到SBFG中，如下： 123456789Name (SBFG, ResourceTemplate () { GpioInt (Level, ActiveLow, ExclusiveAndWake, PullDefault, 0x0000, &quot;\\\\_SB.PCI0.GPI0&quot;, 0x00, ResourceConsumer, , ) { // Pin list 0x0017 // 这一行就是你需要填写的位置！ } }) 接下来就是**_CSR中返回语句的修改了，之前有提到我们_CSR中，我们主要修改的就是其中的Return返回语句，那么GPIO中断呢，需要返回的是SBFB（或是I2CM等）和SBFG。下面是原来的_CSR** 1234567891011121314Method (_CRS, 0, NotSerialized) // _CRS: Current Resource Settings{ If ((OSYS &lt; 0x07DC)) { Return (SBFI) /* \\_SB_.PCI0.I2C0.TPD0.SBFI */ } If ((TPDM == Zero)) { Return (ConcatenateResTemplate (I2CM (I2CX, BADR, SPED), SBFG)) } Return (ConcatenateResTemplate (I2CM (I2CX, BADR, SPED), SBFI))} 这里，我们可以看到上面两个判断语句，我们都可以删除，删到最后就留一条Return (ConcatenateResTemplate (XXXX, XXXX))就行了。如果你的CSR里面还有其他的赋值语句等等或者你搞不懂哪些可以删除，那么你就不要乱删除了，以防删错了，直接修改所有Return语句就行了。修改结果如下： 12345Method (_CRS, 0, NotSerialized) // _CRS: Current Resource Settings{ Return (ConcatenateResTemplate (I2CM (I2CX, BADR, SPED), SBFG)) //Return (ConcatenateResTemplate (SBFB, SBFG))} 这里我们返回了I2CM和SBFG确定了GPIO中断模式。 到这里GPIO中断模式的修改就完成了！ 轮询模式实现这个模式就很简单了，你不需要像GPIO中断模式那样添加GPIO Pin，我们直接修改CSR中的返回语句，最终返回为SBFB和SBFI就行，修改结果如下： 12345Method (_CRS, 0, NotSerialized) // _CRS: Current Resource Settings{ Return (ConcatenateResTemplate (I2CM (I2CX, BADR, SPED), SBFI)) //Return (ConcatenateResTemplate (SBFB, SBFI))} 修改好了GPIO中断或者轮询到这里你的补丁本体就基本完成了！ 禁用原触摸板设备这里我们有两个方法来禁用触摸板设备，第一个方法为预置变量法，第二个方法为**_STA的修改法**，其中，第二个方法是通用的，第一个方法不一定对所有人适用！ 预置变量法禁用原设备目的：禁用原设备，防着你仿冒的设备与原设备发生冲突 这里需要我们观察原设备里的**_STA**，如下： 123456789Method (_STA, 0, NotSerialized) // _STA: Status{ If (((TPDT != Zero) &amp;&amp; (I2CN &amp; One))) { Return (0x0F) } Return (Zero)} 我们看这个If判断语句，意思是如果TPDT不等于Zero，那么则返回0x0F，也就是启用设备。那我们不就只需要让TPDT等于0不就行了吗？那样的话，它就不会执行If语句下的内容了。接下来我们在SSDT中新建一个Scope作用域，路径为根目录并把TPDT赋值为Zero，添加If判断语句确定其只在macOS下生效，如下所示： 1234567Scope (\\){ If (_OSI (&quot;Darwin&quot;)) { TPDT = Zero }} _STA修改法禁用原设备这个需要我们新建一个SSDT，然后我们先写入根作用域（把DSDT中的DefinitionBlock复制到SSDT中就行，然后将里面的DSDT改为SSDT），如下： 123DefinitionBlock (&quot;&quot;, &quot;SSDT&quot;, 2, &quot;DELL&quot;, &quot;CBX3&quot;, 0x01072009){} 然后我们再添加Scope作用域，路径就是原设备（TPD0）的路径，如下： 123456DefinitionBlock (&quot;&quot;, &quot;SSDT&quot;, 2, &quot;DELL&quot;, &quot;CBX3&quot;, 0x01072009){ Scope (_SB.PCI0.I2C0.TPD0) { }} 然后把我下面给出的**_STA复制到这个Scope作用域**中 1234567891011Method (_STA, 0, NotSerialized) // _STA: Status{ If (_OSI (&quot;Darwin&quot;)) { Return (Zero) } Else { Return (XSTA()) }} 这个**_STA的意思差不多就是，在macOS下返回Zero，也就是设备禁用状态，在其他系统下，返回XSTA** 接下来补充引用声明就行了，需要补充的引用声明有两个，一个是TPD0这个设备的，还有一个就是XSTA的，写引用声明可以参考我论坛里的教程： http://bbs.pcbeta.com/viewthread-1866928-1-1.html 也可以看本教程最后一块内容：排错-补充引用声明 最后补丁结果如下： 1234567891011121314151617181920DefinitionBlock (&quot;&quot;, &quot;SSDT&quot;, 2, &quot;DELL&quot;, &quot;CBX3&quot;, 0x01072009){ External (_SB.PCI0.I2C0.TPD0,DeviceObj) External (_SB.PCI0.I2C0.TPD0.XSTA,MethodObj) Scope (_SB.PCI0.I2C0.TPD0) { Method (_STA, 0, NotSerialized) // _STA: Status { If (_OSI (&quot;Darwin&quot;)) { Return (Zero) } Else { Return (XSTA()) } } }} 当然使用这个方法不仅需要补丁，还需要添加重命名，防止**_STA**发生冲突。 我们需要用到Hex Friend这个软件，我们使用Hex Friend打开DSDT，按Option + F（你的可能不同）打开搜索框，在搜索框左侧，将Hex改为Text，然后在Find里搜索你的触摸板设备，我这里是TPD0，左边对于二进制的数字，右边对应字符，在二进制中会用高亮标出你的触摸板设备代表的二进制，然后观察你的这串高亮的数字之后是不是跟着08，是的话，你就找到了自己的触摸板设备，接着需要在右边找到你的触摸板设备，在沿着你的触摸板设备，找到下面的**_STA并把它选中，向右拉长，同时左边的高亮数字也在拉长，大致拉两段多一点就差不多了，复制你左边的高亮数字，粘贴在Find**里搜索，如果除了你现在这段没有搜到其他的，那么就可以了，否则继续拉长再搜索，直到确定只有你这段没有重复！ 然后我们打开config在ACPI部分中，添加重命名补丁： 12345Comment：I2C _STA to XSTA in TPD0Find：5F535441 00A01390 929354 //这是我给出的DSDT中的，你们别抄Replace：58535441 00A01390 929354 //在Replace中将开头的5F改成了58，意思可就是将_STA中的下划线改成了X，其他不变 这个拉长的方法是OC和CLOVER通用的，下面再介绍CLOVER可以用的另一种方法。 在CLOVER中，重命名有一个“桥”可以作为圈定重命名的范围，这个“桥”也就是TgtBridge。如何使用这个TgtBridge呢？很简单，首先我们先将**_STA这四个字符转换为16进制，利用Hackintool就行，打开Hackintool的计算器，在字符串转换中，将_STA填入到ASCII中，复制转换出来的16进制，以此类推，再得到XSTA的16进制**，如下： 1234567Comment：I2C _STA to XSTA in TPD0Find：5F535441 //_STAReplace：58535441 //XSTATgtBridge： 那么TgtBridge怎么填呢？我们修改的**_STA是不是在TPD0下，那么就把_STA的范围也控制在TPD0就行了，我们将TPD0以上面的方法，也转换为16进制就行了，填入到TgtBridge**中去。最后结果如下： 1234567Comment：I2C _STA to XSTA in TPD0Find：5F535441 //_STAReplace：58535441 //XSTATgtBridge：54504430 //TPD0 排错-补充引用声明正确制作完触摸板补丁后，我们会有一些错误，而处理这些错误，需要我们补充引用声明。 见我写的这篇教程中：http://bbs.pcbeta.com/viewthread-1866928-1-1.html 比如我们点击编译，GNUM报错了，那么我们到DSDT中去搜素GNUM，找到其被定义的位置所在，写成引用声明External即可。 最终完成的补丁如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259DefinitionBlock (&quot;&quot;, &quot;SSDT&quot;, 2, &quot;DELL &quot;, &quot;TPXX &quot;, 0x01072009){ External (_SB_.GNUM, MethodObj) // 1 Arguments External (_SB_.INUM, MethodObj) // 1 Arguments External (_SB_.PCI0.HIDD, MethodObj) // 5 Arguments External (_SB_.PCI0.HIDG, IntObj) External (_SB_.PCI0.I2C0, DeviceObj) External (_SB_.PCI0.I2C0.I2CX, IntObj) External (_SB_.PCI0.I2CM, MethodObj) // 3 Arguments External (_SB_.PCI0.TP7D, MethodObj) // 6 Arguments External (_SB_.PCI0.TP7G, IntObj) External (_SB_.SHPO, MethodObj) // 2 Arguments External (CBID, FieldUnitObj) External (GPDI, FieldUnitObj) External (TPDB, FieldUnitObj) External (TPDH, FieldUnitObj) External (TPDM, FieldUnitObj) External (TPDS, FieldUnitObj) External (TPDT, FieldUnitObj) Scope (\\) { If (_OSI (&quot;Darwin&quot;)) { TPDT = Zero } } Scope (_SB.PCI0.I2C0) { Device (TPXX) { Name (HID2, Zero) Name (SBFB, ResourceTemplate () { I2cSerialBusV2 (0x0000, ControllerInitiated, 0x00061A80, AddressingMode7Bit, &quot;NULL&quot;, 0x00, ResourceConsumer, _Y00, Exclusive, ) }) Name (SBFG, ResourceTemplate () { GpioInt (Level, ActiveLow, ExclusiveAndWake, PullDefault, 0x0000, &quot;\\\\_SB.PCI0.GPI0&quot;, 0x00, ResourceConsumer, , ) { // Pin list 0x0000 } }) Name (SBFI, ResourceTemplate () { Interrupt (ResourceConsumer, Level, ActiveLow, ExclusiveAndWake, ,, _Y01) { 0x00000000, } }) CreateWordField (SBFB, \\_SB.PCI0.I2C0.TPXX._Y00._ADR, BADR) // _ADR: Address CreateDWordField (SBFB, \\_SB.PCI0.I2C0.TPXX._Y00._SPE, SPED) // _SPE: Speed CreateWordField (SBFG, 0x17, INT1) CreateDWordField (SBFI, \\_SB.PCI0.I2C0.TPXX._Y01._INT, INT2) // _INT: Interrupts Method (GTID, 1, Serialized) { If (Arg0) { Switch (CBID) { Case (0x0896) { Return (&quot;DELL0896&quot;) } Case (0x0895) { Return (&quot;DELL0895&quot;) } Case (0x0894) { Return (&quot;DELL0894&quot;) } Case (0x08A5) { Return (&quot;DELL08A5&quot;) } Case (0x08A6) { Return (&quot;DELL08A6&quot;) } Case (0x089C) { Return (&quot;DELL089C&quot;) } Case (0x089D) { Return (&quot;DELL089D&quot;) } Case (0x089E) { Return (&quot;DELL089E&quot;) } Case (0x089F) { Return (&quot;DELL089F&quot;) } Case (0x08A7) { Return (&quot;DELL08A7&quot;) } Case (0x08A8) { Return (&quot;DELL08A8&quot;) } Case (0x08A9) { Return (&quot;DELL08A9&quot;) } Case (0x08BC) { Return (&quot;DELL08BC&quot;) } Case (0x08BD) { Return (&quot;DELL08BD&quot;) } Case (0x08C0) { Return (&quot;DELL08C0&quot;) } Case (0x0949) { Return (&quot;DELL0949&quot;) } Default { Return (&quot;DELL0949&quot;) } } } Else { Return (0x20) } } Method (_INI, 0, Serialized) // _INI: Initialize { INT1 = GNUM (GPDI) INT2 = INUM (GPDI) If ((TPDM == Zero)) { SHPO (GPDI, One) } If (One) { _HID = &quot;SYNA2393&quot; HID2 = 0x20 Return (Zero) } If (One) { _HID = &quot;06CB2846&quot; HID2 = 0x20 Return (Zero) } If (One) { _HID = &quot;ALPS0000&quot; HID2 = 0x20 BADR = 0x2C Return (Zero) } If (One) { _HID = GTID (One) HID2 = TPDH /* External reference */ Switch (CBID) { Case (0x08BC) { BADR = 0x15 } Case (0x08BD) { BADR = TPDB /* External reference */ } Case (0x08C0) { BADR = TPDB /* External reference */ } Default { BADR = TPDB /* External reference */ } } If ((TPDS == Zero)) { SPED = 0x000186A0 } If ((TPDS == One)) { SPED = 0x00061A80 } If ((TPDS == 0x02)) { SPED = 0x000F4240 } Return (Zero) } } Name (_HID, &quot;XXXX0000&quot;) // _HID: Hardware ID Name (_CID, &quot;PNP0C50&quot; /* HID Protocol Device (I2C bus) */) // _CID: Compatible ID Name (_S0W, 0x03) // _S0W: S0 Device Wake State Method (_DSM, 4, Serialized) // _DSM: Device-Specific Method { If ((Arg0 == HIDG)) { Return (HIDD (Arg0, Arg1, Arg2, Arg3, HID2)) } If ((Arg0 == TP7G)) { Return (TP7D (Arg0, Arg1, Arg2, Arg3, SBFB, SBFG)) } Return (Buffer (One) { 0x00 // . }) } Method (_STA, 0, NotSerialized) // _STA: Status { If (_OSI (&quot;Darwin&quot;)) { Return (0x0F) } Else { Return (Zero) } } Method (_CRS, 0, NotSerialized) // _CRS: Current Resource Settings { Return (ConcatenateResTemplate (I2CM (I2CX, BADR, SPED), SBFG)) } } }} 这里也给出样本的DSDT与SSDT： 链接: https://pan.baidu.com/s/1eGHOyGc6AleEr1aHZxWYaA 提取密码：s9t2 鸣谢特别感谢以下几位大佬的支持： @penghuibingzhou 本教程建立在penghuibingzhou的教程上，进行了修改，本家如下： https://www.penghubingzhou.cn/2019/01/06/VoodooI2C%20DSDT%20Edit/ @Bat.bat 感谢Bat大佬的鼎力支持！ 本教程由Bat进行指导和修改！在Bat大佬的大力帮助下，教程进行了修改和完善，纠正了许多错误的地方！","link":"/2020/05/17/%E7%94%A8%E7%83%AD%E8%A1%A5%E4%B8%81%E4%BF%AE%E7%90%86%E4%BD%A0%E7%9A%84%E8%A7%A6%E6%91%B8%E6%9D%BF%EF%BC%88TouchPad-Hotpatch%EF%BC%89/"}],"tags":[{"name":"黑苹果","slug":"黑苹果","link":"/tags/%E9%BB%91%E8%8B%B9%E6%9E%9C/"},{"name":"系统","slug":"系统","link":"/tags/%E7%B3%BB%E7%BB%9F/"},{"name":"软件分享","slug":"软件分享","link":"/tags/%E8%BD%AF%E4%BB%B6%E5%88%86%E4%BA%AB/"},{"name":"二次元&#x2F;动漫","slug":"二次元-动漫","link":"/tags/%E4%BA%8C%E6%AC%A1%E5%85%83-%E5%8A%A8%E6%BC%AB/"}],"categories":[{"name":"技术","slug":"技术","link":"/categories/%E6%8A%80%E6%9C%AF/"},{"name":"杂谈","slug":"杂谈","link":"/categories/%E6%9D%82%E8%B0%88/"}]}