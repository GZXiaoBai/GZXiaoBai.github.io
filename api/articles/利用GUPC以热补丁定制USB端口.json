{"title":"利用GUPC以热补丁定制USB端口","uid":"8988c31c9c6b01303dadfca403bf5e1f","slug":"利用GUPC以热补丁定制USB端口","date":"2021-05-09T06:30:18.000Z","updated":"2021-05-22T11:13:43.327Z","comments":true,"path":"api/articles/利用GUPC以热补丁定制USB端口.json","keywords":null,"cover":"https://i.loli.net/2021/05/22/qZOCU6QIdDzblTL.jpg","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>虽然之前就有用热补丁定制USB端口的方法，但那个方法需要搭配<strong>USBAllinject.kext</strong>使用，在受到Github中一个issue的启发后，我们发现，可以利用ACPI中的<strong>GUPC</strong>实现USB端口的热补丁定制。最后，通过咨询了<strong>哞大</strong>相关问题，发此贴，提供方法。</p>\n<p>Github的issue链接如下：<a href=\"https://github.com/daliansky/OC-little/issues/18\">https://github.com/daliansky/OC-little/issues/18</a></p>\n<p><code>PS:华硕可能并不适用此方法</code></p>\n<span id=\"more\"></span>\n\n<h1 id=\"基本原理\"><a href=\"#基本原理\" class=\"headerlink\" title=\"基本原理\"></a>基本原理</h1><p>我们这边就以那个issue为样例进行说明</p>\n<p>机型原始<strong>GUPC</strong>方法为：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">Method (GUPC, 1, Serialized)\n&#123;\n    Name (PCKG, Package (0x04)\n    &#123;\n        Zero, \n        0xFF, \n        Zero, \n        Zero\n    &#125;)\n    PCKG [Zero] &#x3D; Arg0\n    Return (PCKG)\n&#125;</code></pre>\n\n<p>首先，我们先来了解下PkgObj的一些基本知识</p>\n<p>在<code>PCKG, Package (0x04)</code>中，我们不难发现 <strong>0x04</strong> 对应了下面的四个项，也就是 <code>Zero</code>、<code>0xFF</code>、<code>Zero</code>、<code>Zero</code>这些，也就是说，Pkg下有几个项，这里的值就对应是多少，比如有三个那么就是 <strong>0x03</strong> (<em><strong><u>PS：这里的值为16进制</u></strong></em>)</p>\n<p>然后，我们再来看Pkg中的项的位置：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">···\n    Name (PCKG, Package (0x04)\n    &#123;\n        Zero, &#x2F;&#x2F;第一个项的位置为：Zero\n        0xFF, &#x2F;&#x2F;第二个项的位置为：One\n        Zero, &#x2F;&#x2F;第三个项的位置为：0x03\n        Zero  &#x2F;&#x2F;第四个项的位置为：0x04\n    &#125;)\n    PCKG [Zero] &#x3D; Arg0\n    Return (PCKG)\n···</code></pre>\n\n<p>这样子应该就一目了然了吧，以此类推下去就行，记住一点，初始位并不是 <strong>One</strong> 而是 <strong>Zero</strong></p>\n<h1 id=\"实现定制\"><a href=\"#实现定制\" class=\"headerlink\" title=\"实现定制\"></a>实现定制</h1><p>这里我们给出一个修改完成的样例：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">DefinitionBlock (&quot;&quot;, &quot;SSDT&quot;, 2, &quot;INTEL&quot;, &quot;GUPC&quot;, 0x00000000)\n&#123;\n    External (_SB.PCI0.XHC.RHUB, DeviceObj)\n    External (_SB.PCI0.XHC.RHUB.XUPC, MethodObj)\n    \n    Scope (_SB.PCI0.XHC.RHUB)\n    &#123;\n        Name (USBP, Zero)\n        Method (GUPC, 1, Serialized)\n        &#123;\n            If (_OSI (&quot;Darwin&quot;))\n            &#123;\n                Name (PCKG, Package (0x04)\n                &#123;\n                    0xFF, \n                    0x03, \n                    Zero, \n                    Zero\n                &#125;)\n                USBP +&#x3D; One\n                If (((USBP &#x3D;&#x3D; 0x04) || (Arg0 &#x3D;&#x3D; Zero)))\n                &#123;\n                    PCKG [Zero] &#x3D; Zero\n                &#125;\n\n                If ((((USBP &#x3D;&#x3D; 0x04) || (USBP &#x3D;&#x3D; 0x05)) || (USBP &#x3D;&#x3D; 0x06)))\n                &#123;\n                    PCKG [One] &#x3D; 0xFF\n                &#125;\n\n                Return (PCKG) \n            &#125;\n            Else\n            &#123;\n                Return (XUPC(Arg0))\n            &#125;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>现在我们来一一解释一下，我们要明白在ACPI中，每个端口都有对应的<code>_UPC</code>方法来返回<code>GUPC</code>的值来确定端口的<strong>状态(开启或者关闭)<strong>以及</strong>类型</strong>，<code>_UPC</code>方法见下:</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">Method (_UPC, 0, NotSerialized) \n&#123;\n    Return (GUPC(One)) \n&#125;</code></pre>\n\n<p>那这个返回语句中的<strong>One</strong>是什么意思呢？其实这个<strong>One</strong>赋值给了<strong>GUPC</strong>方法中的<strong>Arg0</strong>，我们看到原来的<strong>GUPC</strong>方法中，有这个一句：<code>PCKG [Zero] = Arg0</code>，也就是这个端口在返回<strong>GUPC</strong>这个方法时。将<strong>Arg0</strong>赋值为了<strong>One</strong>，那么<code>PCKG [Zero] = Arg0</code>中，<strong>PCKG</strong>后面跟着的<strong>Zero</strong>又是什么意思呢？这个其实联系我之前讲的Pkg中<strong>项的位置</strong>就很好理解了，这里对应的就是<strong>PCKG中Zero位置的项</strong>，那么整句话的意思就是：**<u>将PCKG这个Pkg中Zero位置的项覆盖为Arg0的值</u>**</p>\n<p>而在<strong>GUPC</strong>方法里的<strong>PCKG</strong>中，也正是<strong>Zero位置的项</strong>和<strong>One位置的项</strong>决定着端口的<strong>状态</strong>和<strong>类型</strong>：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">···\n    Name (PCKG, Package (0x04)\n    &#123;\n        Zero, &#x2F;&#x2F;Zero位置[决定端口状态]: Zero为关闭，其它值都为开启\n        0xFF, &#x2F;&#x2F;One位置 [决定端口类型]：详细对应可见下面我给出的表\n        Zero, &#x2F;&#x2F;此值为保留，必须为Zero\n        Zero  &#x2F;&#x2F;此值为保留，必须为Zero\n    &#125;)\n···</code></pre>\n\n<p><strong>One</strong>位置的值所对应的<strong>端口类型</strong>：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">---------------------------\n&#x2F;&#x2F;常用值\n0x03  &#x2F;&#x2F;USB3.0 Type-A\n0x09  &#x2F;&#x2F;TypeC Type C+sw 10\n0xFF  &#x2F;&#x2F;内建 专用连接器\n---------------------------\n&#x2F;&#x2F;完整表\n0x00  &#x2F;&#x2F;类型”A”连接器\n0x01  &#x2F;&#x2F;Mini-AB连接器\n0x02  &#x2F;&#x2F;ExpressCard\n0x03  &#x2F;&#x2F;USB3标注A连接器\n0x04  &#x2F;&#x2F;USB3标注B连接器\n0x05  &#x2F;&#x2F;USB3 Micro-B连接器\n0x06  &#x2F;&#x2F;USB3 Micro-AB连接器\n0x07  &#x2F;&#x2F;USB3 Micro-B连接器\n0x08-0xFE  &#x2F;&#x2F;保留\n0xFF  &#x2F;&#x2F;专用连接器\n---------------------------</code></pre>\n\n<p>好了，知道了这些我们就可以正式开始着手定制我们的USB端口了。</p>\n<p>你们看我给出的完整补丁里，定义了一个<strong>USBP</strong>，并赋值为了<strong>Zero</strong>，然后又在GUPC这个方法中添加了语句：<code>USBP += One</code>，让<strong>USBP</strong>的值加上1，其实定义这个<strong>USBP</strong>其实是为了帮我们<strong>定位对应的端口</strong>，由于<strong>GUPC</strong>方法是<strong>Serialized</strong>，所以每次在一个端口调用完<strong>GUPC</strong>后，它并不会重置，所以我们可以添加一个<strong>USBP</strong>，每被一个端口调用一次，<strong>USBP</strong>的值就增加1，那么当第一个端口调用<strong>GUPC</strong>时，<strong>USBP</strong>为<strong>1</strong>，第二个端口再调用时，<strong>USBP</strong>的值就在1的基础上再加1，也就是<strong>2</strong>。</p>\n<p>那么就可以很好理解了，这样的话，每一个端口都会按顺序对应一个相应的<strong>USBP</strong>的值。</p>\n<p>接下来，我们在添加判断语句来确定每个端口的<strong>状态</strong>和<strong>类型</strong>(见上面给出的完整补丁)：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\"> ···               \n     If (((USBP &#x3D;&#x3D; 0x04) || (Arg0 &#x3D;&#x3D; Zero)))\n     &#123;\n         PCKG [Zero] &#x3D; Zero\n     &#125;\n\n     If ((((USBP &#x3D;&#x3D; 0x04) || (USBP &#x3D;&#x3D; 0x05)) || (USBP &#x3D;&#x3D; 0x06)))\n     &#123;\n         PCKG [One] &#x3D; 0xFF\n     &#125;\n···</code></pre>\n\n<p>我们来先来理解一下第一段判断语句的意思，就是：</p>\n<ul>\n<li>当 <strong>USBP = 0x04 <strong>或者 <strong>Arg0 = Zero</strong> 的时候，将</strong>PCKG</strong>中<strong>Zero位置</strong>的值覆盖为<strong>Zero</strong>，也就是禁用<strong>第四个端口</strong>和<strong>返回的Arg0的值为Zero的端口</strong>。</li>\n</ul>\n<p>我们再来看第二段判断语句的意思：</p>\n<ul>\n<li>当 <strong>USBP  = 0x04</strong> 或者 <strong>USBP  = 0x05</strong> 或者 <strong>USBP  = 0x06</strong> 的时候，将<strong>PCKG</strong>中<strong>One位置</strong>的项的值覆盖为<strong>0xFF</strong>，也就是把<strong>第四、五、六端口</strong>的类型定义为<strong>内建</strong>。</li>\n</ul>\n<p>当然，我们可以根据自己的需求去写判断语句，以达到我们想定制的效果，哪些端口开，哪些端口关，并定义这些端口的类型。</p>\n<p>最后我们再返回<strong>PCKG</strong>就OK了，添加好<code>If (_OSI (&quot;Darwin&quot;))</code>语句来判定在<strong>macOS</strong>系统下生效，最后我们在<strong>Config</strong>中补充<strong>重命名</strong>：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">Comment: USB GUPC to XUPC\nFind: 47 55 50 43 09\nReplace: 58 55 50 43 09</code></pre>\n\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>好了，这也是这个教程的主要部分了，希望能给大家定制USB以一个新的方法思路！</p>\n","text":"前言虽然之前就有用热补丁定制USB端口的方法，但那个方法需要搭配USBAllinject.kext使用，在受到Github中一个issue的启发后，我们发现，可以利用ACPI中的GUPC实现USB端口的热补丁定制。最后，通过咨询了哞大相关问题，发此贴，提供方法。 Github的i...","link":"","photos":[],"count_time":{"symbolsCount":"4.5k","symbolsTime":"4 mins."},"categories":[{"name":"技术","slug":"技术","count":10,"path":"api/categories/技术.json"}],"tags":[{"name":"黑苹果","slug":"黑苹果","count":7,"path":"api/tags/黑苹果.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">基本原理</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E5%AE%9A%E5%88%B6\"><span class=\"toc-text\">实现定制</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%BB%93%E8%AF%AD\"><span class=\"toc-text\">结语</span></a></li></ol>","author":{"name":"神楽小白(GZ小白)的部落阁","slug":"blog-author","avatar":"https://i.loli.net/2021/05/15/QdcDz8P721AfEMR.jpg","link":"/","description":"这是一个正常的人(确信)!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":{"icon":"/svg/github.svg","link":"https://github.com/GZXiaoBai"},"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/355276854"}}}},"mapped":true,"prev_post":{"title":"Hackintosh安装全攻略","uid":"abffe26bc69808327979060f3d56b2b3","slug":"Hackintosh安装全攻略","date":"2020-05-16T14:09:02.000Z","updated":"2021-05-04T08:40:05.691Z","comments":true,"path":"api/articles/Hackintosh安装全攻略.json","keywords":null,"cover":"https://i.loli.net/2021/05/02/yGEk9xwH86jRo4X.jpg","text":"以下内容基本摘自Eternal Qiu的博客，日后准备进行修改链接：https://blog.qiuxiangzhi.top/2019/07/15/macOS-Guide/ 前言我打算写一个教程来引导小白入坑，不在本文介绍那些复杂需要折腾的驱动问题。 警告请注意，本贴只做技术与学...","link":"","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[{"name":"技术","slug":"技术","count":10,"path":"api/categories/技术.json"}],"tags":[{"name":"黑苹果","slug":"黑苹果","count":7,"path":"api/tags/黑苹果.json"}],"author":{"name":"神楽小白(GZ小白)的部落阁","slug":"blog-author","avatar":"https://i.loli.net/2021/05/15/QdcDz8P721AfEMR.jpg","link":"/","description":"这是一个正常的人(确信)!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":{"icon":"/svg/github.svg","link":"https://github.com/GZXiaoBai"},"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/355276854"}}}},"feature":true},"next_post":{"title":"黑苹果论坛必备App-一个集成热门论坛app","uid":"15880c002e24100ea6712f8aa253deb3","slug":"黑苹果论坛必备App-一个集成热门论坛app","date":"2020-08-11T06:01:07.000Z","updated":"2021-05-22T10:32:09.446Z","comments":true,"path":"api/articles/黑苹果论坛必备App-一个集成热门论坛app.json","keywords":null,"cover":"https://i.loli.net/2021/05/22/VtnNYJydv2mbjGu.jpg","text":"前言这是你迈上黑苹果之路的方向引导！ 软件分享链接: https://pan.baidu.com/s/1yWI5Agap32pbb2lqxYSriQ 密码: 77vh 感谢感谢**@仙女plus(软件作者),同时仙女也是OpenCOre霓虹灯主题**的作者，希望大家多多这次一下哈...","link":"","photos":[],"count_time":{"symbolsCount":144,"symbolsTime":"1 mins."},"categories":[{"name":"技术","slug":"技术","count":10,"path":"api/categories/技术.json"}],"tags":[{"name":"系统","slug":"系统","count":2,"path":"api/tags/系统.json"}],"author":{"name":"神楽小白(GZ小白)的部落阁","slug":"blog-author","avatar":"https://i.loli.net/2021/05/15/QdcDz8P721AfEMR.jpg","link":"/","description":"这是一个正常的人(确信)!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":{"icon":"/svg/github.svg","link":"https://github.com/GZXiaoBai"},"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/355276854"}}}}}}