{"title":"进阶：电池热补丁（Battery-Hotpatch）之路","uid":"0b0d58a227f41342a3d42cd20e4f9a94","slug":"进阶：电池热补丁（Battery-Hotpatch）之路","date":"2020-05-16T14:12:07.000Z","updated":"2021-06-04T10:14:28.740Z","comments":true,"path":"api/articles/进阶：电池热补丁（Battery-Hotpatch）之路.json","keywords":null,"cover":"https://i.loli.net/2021/05/02/WEqjSwnGl8LcAQB.png","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在有了OpenCore的引导后，已经<strong>不在推荐使用DSDT</strong>了，况且，现在也是主要推广<strong>热补丁（HotPatch）</strong>，热补丁具有比DSDT更好的<strong>灵活性</strong>，于是便开始写这篇文章了。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"准备步骤\"><a href=\"#准备步骤\" class=\"headerlink\" title=\"准备步骤\"></a>准备步骤</h1><p>首先，我们需要下载我提供的电池热补丁的样本（SSDT-BATT.dsl)。同时，我还准备了联想X260的电池热补丁作为例子。<br>链接如下：<a href=\"https://pan.baidu.com/s/1E85uJJGzq5EXUpcTTE-CDQ\">百度云</a>  <strong>密码:fn1v</strong><br>然后，准备你的DSDT或者SSDT（存储有EC缓冲区的，Embedded Controller Buffer）</p>\n<p>需要工具：<code>Hackintool，Maciasl，科学计算器（Mac自带）</code></p>\n<p>要求：最好有一定的电池的基础知识，详细看见我之前写的<a href=\"https://blog.gzxiaobai.cn/post/%E4%B8%BA%E5%B0%8F%E7%99%BD%E8%AE%BE%E8%AE%A1%E7%9A%84%E7%94%B5%E6%B1%A0%E6%95%99%E7%A8%8B%EF%BC%88DSDT%EF%BC%89\">电池DSDT的教程</a></p>\n<h1 id=\"初步动作\"><a href=\"#初步动作\" class=\"headerlink\" title=\"初步动作\"></a>初步动作</h1><p>打开热补丁样本，我们来进行一些修改。（按照我自己的习惯来的）</p>\n<p><img src=\"https://i.loli.net/2021/05/02/yqGiaW5O3YoShDN.png\"></p>\n<p>我们要修改的有三处：<br>1.DefinitionBlock的修改，将这里的<strong>ACDT</strong>改为自己<strong>DSDT开头DefinitionBlock里的第三项</strong><br>2.DefinitionBlock的修改，将最后的数值也改成自己DSDT里的<br>3.External引用路径里的EC路径，改成自己DSDT里的实际路径</p>\n<p><img src=\"https://i.loli.net/2021/05/02/d87ozBiXRUjbrIP.png\"></p>\n<p>这里我们有一处要修改：<br>1.Scope路径下，改为自己DSDT里的实际路径</p>\n<h1 id=\"16位和32位的处理\"><a href=\"#16位和32位的处理\" class=\"headerlink\" title=\"16位和32位的处理\"></a>16位和32位的处理</h1><p>这里的处理，其实与DSDT里的差不多。<br>我们先将Field复制到SSDT里<br><img src=\"https://i.loli.net/2021/05/02/nCh1BjQLyH5xmck.png\"></p>\n<p><img src=\"https://i.loli.net/2021/05/02/ZyLeIlPnU3CqW5N.png\"><br>像我这样复制下来，里面到内容不复制。<br><em><strong>注意⚠️：你不难发现，我这里有许多的Field，那是因为X260的DSDT里，就是像这样的分散的Field。因此，当你制作电池热补丁时，搜索EmbeddedControllerBuffer找到Field后，记得同时搜索Field的名称，比如，ECOR，看看有没有分散在其它地方的</strong></em></p>\n<p>复制过来后，我们需要将Field进行<strong>改名</strong>，比如，ECOR，我改为了ECOX，这样就不会与原ACPI里的发生冲突。</p>\n<p>热补丁与DSDT的拆分不同，我们直接将需要拆分的，拆好放到SSDT中，我们创建的Field下。</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">OperationRegion (ECOX, EmbeddedControl, Zero, 0x0100)\nField (ECOX, ByteAcc, NoLock, Preserve)\n&#123;\n    Offset (0xA0), \n    RCB0,   8, \n    RCB1,   8, \n    FCB0,   8, \n    FCB1,   8, \n    Offset (0xA8), \n    ACB0,   8, \n    ACB1,   8, \n    VOB0,   8, \n    VOB1,   8\n&#125;\n\nField (ECOX, ByteAcc, NoLock, Preserve)\n&#123;\n    Offset (0xA0), \n    BMB0,   8, \n    BMB1,   8\n&#125;\n\nField (ECOX, ByteAcc, NoLock, Preserve)\n&#123;\n    Offset (0xA0), \n    DCB0,   8, \n    DCB1,   8, \n    DVB0,   8, \n    DVB1,   8, \n    Offset (0xAA), \n    SNB0,   8, \n    SNB1,   8\n&#125;\n\nField (ECOX, ByteAcc, NoLock, Preserve)\n&#123;\n    Offset (0xA0), \n    CHB0,   8, \n    CHB1,   8, \n    CHB2,   8, \n    CHB3,   8\n&#125;</code></pre>\n<p>最后的结果就如上所示，正确拆分，正确计算偏移量。（这些都包含在我DSDT的教程中）</p>\n<p>接着我们在DSDT中搜索需要被拆分的字节，找到所在的Method，记下路径，然后在SSDT里，添加这个路径。<br>比如我们，发现GBIF这个Method里面有需要拆分的自己，观察所得，GBIF所在的路径为：</p>\n<p><code>_SB.PCI0.LPC.EC</code></p>\n<p>那么我们就在SSDT中加上这个Scope：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">Scope (\\_SB.PCI0.LPC.EC)\n&#123;\n&#125;</code></pre>\n<p>然后，我们将GBIF这一整个Method复制到这个路径下，在对字节进行拆分。（以此类推，其它Method也是这么处理）</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">Method (GBIF, 3, NotSerialized)\n&#123;\n    If (_OSI (&quot;Darwin&quot;))\n    &#123;\n        Acquire (BATM, 0xFFFF)\n        If (Arg2)\n        &#123;\n            Or (Arg0, One, HIID)\n            Store (B1B2 (BMB0, BMB1), Local7)\n            ShiftRight (Local7, 0x0F, Local7)\n            XOr (Local7, One, Index (Arg1, Zero))\n            Store (Arg0, HIID)\n            If (Local7)\n            &#123;\n                Multiply (B1B2 (FCB0, FCB1), 0x0A, Local1)\n            &#125;\n            Else\n            &#123;\n                Store (B1B2 (FCB0, FCB1), Local1)\n            &#125;\n\n            Store (Local1, Index (Arg1, 0x02))\n            Or (Arg0, 0x02, HIID)\n            If (Local7)\n            &#123;\n                Multiply (B1B2 (DCB0, DCB1), 0x0A, Local0)\n            &#125;\n            Else\n            &#123;\n                Store (B1B2 (DCB0, DCB1), Local0)\n            &#125;\n\n            Store (Local0, Index (Arg1, One))\n            Divide (Local1, 0x14, Local2, Index (Arg1, 0x05))\n            If (Local7)\n            &#123;\n                Store (0xC8, Index (Arg1, 0x06))\n            &#125;\n            ElseIf (B1B2 (DVB0, DVB1))\n            &#123;\n                Divide (0x00030D40, B1B2 (DVB0, DVB1), Local2, Index (Arg1, 0x06))\n            &#125;\n            Else\n            &#123;\n                Store (Zero, Index (Arg1, 0x06))\n            &#125;\n\n            Store (B1B2 (DVB0, DVB1), Index (Arg1, 0x04))\n            Store (B1B2 (SNB0, SNB1), Local0)\n            Name (SERN, Buffer (0x06)\n            &#123;\n                &quot;     &quot;\n            &#125;)\n            Store (0x04, Local2)\n            While (Local0)\n            &#123;\n                Divide (Local0, 0x0A, Local1, Local0)\n                Add (Local1, 0x30, Index (SERN, Local2))\n                Decrement (Local2)\n            &#125;\n\n            Store (SERN, Index (Arg1, 0x0A))\n            Or (Arg0, 0x06, HIID)\n            Store (RECB (0xA0, 0x80), Index (Arg1, 0x09))\n            Or (Arg0, 0x04, HIID)\n            Name (BTYP, Buffer (0x05)\n            &#123;\n                 0x00, 0x00, 0x00, 0x00, 0x00                   \n            &#125;)\n            Store (B1B4 (CHB0, CHB1, CHB2, CHB3), BTYP)\n            Store (BTYP, Index (Arg1, 0x0B))\n            Or (Arg0, 0x05, HIID)\n            Store (RECB (0xA0, 0x80), Index (Arg1, 0x0C))\n        &#125;\n        Else\n        &#123;\n            Store (0xFFFFFFFF, Index (Arg1, One))\n            Store (Zero, Index (Arg1, 0x05))\n            Store (Zero, Index (Arg1, 0x06))\n            Store (0xFFFFFFFF, Index (Arg1, 0x02))\n        &#125;\n\n        Release (BATM)\n        Return (Arg1)\n    &#125;\n    Else\n    &#123;\n        Return (XBIF (Arg0, Arg1, Arg2))\n    &#125;\n&#125;\n\nMethod (GBST, 4, NotSerialized)\n&#123;\n    If (_OSI (&quot;Darwin&quot;))\n    &#123;\n        Acquire (BATM, 0xFFFF)\n        If (And (Arg1, 0x20))\n        &#123;\n            Store (0x02, Local0)\n        &#125;\n        ElseIf (And (Arg1, 0x40))\n        &#123;\n            Store (One, Local0)\n        &#125;\n        Else\n        &#123;\n            Store (Zero, Local0)\n        &#125;\n\n        If (And (Arg1, 0x07))&#123;&#125;\n        Else\n        &#123;\n            Or (Local0, 0x04, Local0)\n        &#125;\n\n        If (LEqual (And (Arg1, 0x07), 0x07))\n        &#123;\n            Store (0x04, Local0)\n            Store (Zero, Local1)\n            Store (Zero, Local2)\n            Store (Zero, Local3)\n        &#125;\n        Else\n        &#123;\n            Store (Arg0, HIID)\n            Store (B1B2 (VOB0, VOB1), Local3)\n            If (Arg2)\n            &#123;\n                Multiply (B1B2 (RCB0, RCB1), 0x0A, Local2)\n            &#125;\n            Else\n            &#123;\n                Store (B1B2 (RCB0, RCB1), Local2)\n            &#125;\n\n            Store (B1B2 (ACB0, ACB1), Local1)\n            If (LGreaterEqual (Local1, 0x8000))\n            &#123;\n                If (And (Local0, One))\n                &#123;\n                    Subtract (0x00010000, Local1, Local1)\n                &#125;\n                Else\n                &#123;\n                    Store (Zero, Local1)\n                &#125;\n            &#125;\n            ElseIf (LNot (And (Local0, 0x02)))\n            &#123;\n                Store (Zero, Local1)\n            &#125;\n\n            If (Arg2)\n            &#123;\n                Multiply (Local3, Local1, Local1)\n                Divide (Local1, 0x03E8, Local7, Local1)\n            &#125;\n        &#125;\n\n        Store (Local0, Index (Arg3, Zero))\n        Store (Local1, Index (Arg3, One))\n        Store (Local2, Index (Arg3, 0x02))\n        Store (Local3, Index (Arg3, 0x03))\n        Release (BATM)\n        Return (Arg3)\n    &#125;\n    Else\n    &#123;\n        Return (XBST (Arg0, Arg1, Arg2, Arg3))\n    &#125;\n&#125;</code></pre>\n<p>如上所示，即为最后的处理结果。</p>\n<h1 id=\"32位以上字节的处理\"><a href=\"#32位以上字节的处理\" class=\"headerlink\" title=\"32位以上字节的处理\"></a>32位以上字节的处理</h1><p>步骤基本相同，也是搜索所需修改字节对应对Method，然后找到对应路径，添加到SSDT中。<br><em><strong>32位以上的，不需要Field下的更改，只需要改Method，进行RECB和WECB的处理</strong></em></p>\n<p>详细见DSDT教程中。</p>\n<p>以下为完整处理结果（其实也在上文Method的GBIF，GBST中）（包含了全部）</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">Scope (\\_SB.PCI0.LPC.EC)\n&#123;\n    Method (RE1B, 1, NotSerialized)\n    &#123;\n        OperationRegion (ERM2, EmbeddedControl, Arg0, One)\n        Field (ERM2, ByteAcc, NoLock, Preserve)\n        &#123;\n            BYTE,   8\n        &#125;\n\n        Return (BYTE)\n    &#125;\n\n    Method (RECB, 2, Serialized)\n    &#123;\n        ShiftRight (Add (Arg1, 0x07), 0x03, Arg1)\n        Name (TEMP, Buffer (Arg1)&#123;&#125;)\n        Add (Arg1, Arg0, Arg1)\n        Store (Zero, Local0)\n        While (LLess (Arg0, Arg1))\n        &#123;\n            Store (RE1B (Arg0), Index (TEMP, Local0))\n            Increment (Arg0)\n            Increment (Local0)\n        &#125;\n\n        Return (TEMP)\n    &#125;\n\n    OperationRegion (ECOX, EmbeddedControl, Zero, 0x0100)\n    Field (ECOX, ByteAcc, NoLock, Preserve)\n    &#123;\n        Offset (0xA0), \n        RCB0,   8, \n        RCB1,   8, \n        FCB0,   8, \n        FCB1,   8, \n        Offset (0xA8), \n        ACB0,   8, \n        ACB1,   8, \n        VOB0,   8, \n        VOB1,   8\n    &#125;\n\n    Field (ECOX, ByteAcc, NoLock, Preserve)\n    &#123;\n        Offset (0xA0), \n        BMB0,   8, \n        BMB1,   8\n    &#125;\n\n    Field (ECOX, ByteAcc, NoLock, Preserve)\n    &#123;\n        Offset (0xA0), \n        DCB0,   8, \n        DCB1,   8, \n        DVB0,   8, \n        DVB1,   8, \n        Offset (0xAA), \n        SNB0,   8, \n        SNB1,   8\n    &#125;\n\n    Field (ECOX, ByteAcc, NoLock, Preserve)\n    &#123;\n        Offset (0xA0), \n        CHB0,   8, \n        CHB1,   8, \n        CHB2,   8, \n        CHB3,   8\n    &#125;\n\n    Method (GBIF, 3, NotSerialized)\n    &#123;\n        If (_OSI (&quot;Darwin&quot;))\n        &#123;\n            Acquire (BATM, 0xFFFF)\n            If (Arg2)\n            &#123;\n                Or (Arg0, One, HIID)\n                Store (B1B2 (BMB0, BMB1), Local7)\n                ShiftRight (Local7, 0x0F, Local7)\n                XOr (Local7, One, Index (Arg1, Zero))\n                Store (Arg0, HIID)\n                If (Local7)\n                &#123;\n                    Multiply (B1B2 (FCB0, FCB1), 0x0A, Local1)\n                &#125;\n                Else\n                &#123;\n                    Store (B1B2 (FCB0, FCB1), Local1)\n                &#125;\n\n                Store (Local1, Index (Arg1, 0x02))\n                Or (Arg0, 0x02, HIID)\n                If (Local7)\n                &#123;\n                    Multiply (B1B2 (DCB0, DCB1), 0x0A, Local0)\n                &#125;\n                Else\n                &#123;\n                    Store (B1B2 (DCB0, DCB1), Local0)\n                &#125;\n\n                Store (Local0, Index (Arg1, One))\n                Divide (Local1, 0x14, Local2, Index (Arg1, 0x05))\n                If (Local7)\n                &#123;\n                    Store (0xC8, Index (Arg1, 0x06))\n                &#125;\n                ElseIf (B1B2 (DVB0, DVB1))\n                &#123;\n                    Divide (0x00030D40, B1B2 (DVB0, DVB1), Local2, Index (Arg1, 0x06))\n                &#125;\n                Else\n                &#123;\n                    Store (Zero, Index (Arg1, 0x06))\n                &#125;\n\n                Store (B1B2 (DVB0, DVB1), Index (Arg1, 0x04))\n                Store (B1B2 (SNB0, SNB1), Local0)\n                Name (SERN, Buffer (0x06)\n                &#123;\n                    &quot;     &quot;\n                &#125;)\n                Store (0x04, Local2)\n                While (Local0)\n                &#123;\n                    Divide (Local0, 0x0A, Local1, Local0)\n                    Add (Local1, 0x30, Index (SERN, Local2))\n                    Decrement (Local2)\n                &#125;\n\n                Store (SERN, Index (Arg1, 0x0A))\n                Or (Arg0, 0x06, HIID)\n                Store (RECB (0xA0, 0x80), Index (Arg1, 0x09))\n                Or (Arg0, 0x04, HIID)\n                Name (BTYP, Buffer (0x05)\n                &#123;\n                     0x00, 0x00, 0x00, 0x00, 0x00                   \n                &#125;)\n                Store (B1B4 (CHB0, CHB1, CHB2, CHB3), BTYP)\n                Store (BTYP, Index (Arg1, 0x0B))\n                Or (Arg0, 0x05, HIID)\n                Store (RECB (0xA0, 0x80), Index (Arg1, 0x0C))\n            &#125;\n            Else\n            &#123;\n                Store (0xFFFFFFFF, Index (Arg1, One))\n                Store (Zero, Index (Arg1, 0x05))\n                Store (Zero, Index (Arg1, 0x06))\n                Store (0xFFFFFFFF, Index (Arg1, 0x02))\n            &#125;\n\n            Release (BATM)\n            Return (Arg1)\n        &#125;\n        Else\n        &#123;\n            Return (XBIF (Arg0, Arg1, Arg2))\n        &#125;\n    &#125;\n\n    Method (GBST, 4, NotSerialized)\n    &#123;\n        If (_OSI (&quot;Darwin&quot;))\n        &#123;\n            Acquire (BATM, 0xFFFF)\n            If (And (Arg1, 0x20))\n            &#123;\n                Store (0x02, Local0)\n            &#125;\n            ElseIf (And (Arg1, 0x40))\n            &#123;\n                Store (One, Local0)\n            &#125;\n            Else\n            &#123;\n                Store (Zero, Local0)\n            &#125;\n\n            If (And (Arg1, 0x07))&#123;&#125;\n            Else\n            &#123;\n                Or (Local0, 0x04, Local0)\n            &#125;\n\n            If (LEqual (And (Arg1, 0x07), 0x07))\n            &#123;\n                Store (0x04, Local0)\n                Store (Zero, Local1)\n                Store (Zero, Local2)\n                Store (Zero, Local3)\n            &#125;\n            Else\n            &#123;\n                Store (Arg0, HIID)\n                Store (B1B2 (VOB0, VOB1), Local3)\n                If (Arg2)\n                &#123;\n                    Multiply (B1B2 (RCB0, RCB1), 0x0A, Local2)\n                &#125;\n                Else\n                &#123;\n                    Store (B1B2 (RCB0, RCB1), Local2)\n                &#125;\n\n                Store (B1B2 (ACB0, ACB1), Local1)\n                If (LGreaterEqual (Local1, 0x8000))\n                &#123;\n                    If (And (Local0, One))\n                    &#123;\n                        Subtract (0x00010000, Local1, Local1)\n                    &#125;\n                    Else\n                    &#123;\n                        Store (Zero, Local1)\n                    &#125;\n                &#125;\n                ElseIf (LNot (And (Local0, 0x02)))\n                &#123;\n                    Store (Zero, Local1)\n                &#125;\n\n                If (Arg2)\n                &#123;\n                    Multiply (Local3, Local1, Local1)\n                    Divide (Local1, 0x03E8, Local7, Local1)\n                &#125;\n            &#125;\n\n            Store (Local0, Index (Arg3, Zero))\n            Store (Local1, Index (Arg3, One))\n            Store (Local2, Index (Arg3, 0x02))\n            Store (Local3, Index (Arg3, 0x03))\n            Release (BATM)\n            Return (Arg3)\n        &#125;\n        Else\n        &#123;\n            Return (XBST (Arg0, Arg1, Arg2, Arg3))\n        &#125;\n    &#125;\n&#125;</code></pre>\n<p>可以对照给出的X260的热补丁看看</p>\n<h1 id=\"排错，补充引用声明\"><a href=\"#排错，补充引用声明\" class=\"headerlink\" title=\"排错，补充引用声明\"></a>排错，补充引用声明</h1><p>完成这些步骤后，点击编译会发现错误<br><img src=\"https://i.loli.net/2021/05/02/tUBnsOqaxWFMzgh.png\"></p>\n<p>这些都是因为没有被定义，因此我们需要进行引用，来排除这些错误。<br>以BATM为例，在DSDT中进行搜索，找到它被定义的路径和类型，写成External</p>\n<p><code>External (_SB.PCI0.LPC.EC_BATM, MutexObj)</code></p>\n<p>前者为路径，后者为类型</p>\n<p>更多详见如下：</p>\n<p>以下摘自iStar的博客：<br>Device：原始 ACPI 定义示例</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">Scope (_SB.PCI0.LPCB)\n&#123;\n    Device (H_EC)\n    &#123;</code></pre>\n<p>补丁中添加的代码示例</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">External (_SB_.PCI0.LPCB.H_EC, DeviceObj)</code></pre>\n<p>Method：原始 ACPI 定义示例</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">Method (_STA, 0, NotSerialized)  &#x2F;* _STA: Status *&#x2F;</code></pre>\n<p>补丁中添加的代码示例</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">External (_SB_.BAT0._STA, MethodObj)</code></pre>\n<p>Mutex：原始 ACPI 定义示例</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">Mutex (BATM, 0x07)</code></pre>\n<p>补丁中添加的代码示例</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">External (_SB_.PCI0.LPCB.H_EC.BATM, MutexObj)</code></pre>\n<p>FieldUnit：原始 ACPI 定义示例</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">Field(...)\n&#123;\n...\nBCNT,   8,\n...\n&#125;</code></pre>\n<p>补丁中添加的代码示例</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">External (_SB_.PCI0.LPCB.H_EC.BCNT, FieldUnitObj)</code></pre>\n<p>Integer：原始 ACPI 定义示例</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">Name (ECA2, Zero)</code></pre>\n<p>补丁中添加的代码示例</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">External (_SB_.PCI0.LPCB.H_EC.ECA2, IntObj)</code></pre>\n<p>Package：原始 ACPI 定义示例</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">Name (PBIF, Package (0x0D)\n&#123;\n    One,\n    0xFFFFFFFF,\n    0xFFFFFFFF,\n    One,\n    0xFFFFFFFF,\n    0xFA,\n    0x96,\n    0x0A,\n    0x19,\n    &quot;BAT0&quot;,\n    &quot; &quot;,\n    &quot; &quot;,\n    &quot; &quot;\n&#125;)</code></pre>\n<p>补丁中添加的代码示例</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">External (_SB_.BAT0.PBIF, PkgObj)</code></pre>\n\n<h1 id=\"添加if判断语句\"><a href=\"#添加if判断语句\" class=\"headerlink\" title=\"添加if判断语句\"></a>添加if判断语句</h1><p>为了让自己修改的Method不会影响Windows系统，我们需要添加if判断语句，明确它的内容作用在哪个系统。</p>\n<p>如，在GBIF这个Method的第一个括号下加入<strong>If (_OSI (“Darwin”))</strong></p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\"> Method (GBIF, 3, NotSerialized)\n &#123;\n     If (_OSI (&quot;Darwin&quot;))\n     &#123;\n         Acquire (BATM, 0xFFFF)\n         If (Arg2)\n.....</code></pre>\n<p>然后，我们去到这个Method的尾部，看看这个Method，最后有没有返回（Return）<br>很显然这个GBIF有的，就是<strong>Return (Arg1)</strong><br>对于有返回语句的，我们需要在Else下加上Return，没有则不需要。</p>\n<p>Else部分自己加在Method末尾。</p>\n<p>最终结果如下：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">Method (GBIF, 3, NotSerialized)\n&#123;\n    If (_OSI (&quot;Darwin&quot;))\n    &#123;\n        Acquire (BATM, 0xFFFF)\n        If (Arg2)\n        &#123;\n            Or (Arg0, One, HIID)\n            Store (B1B2 (BMB0, BMB1), Local7)\n            ShiftRight (Local7, 0x0F, Local7)\n            XOr (Local7, One, Index (Arg1, Zero))\n            Store (Arg0, HIID)\n            If (Local7)\n            &#123;\n                Multiply (B1B2 (FCB0, FCB1), 0x0A, Local1)\n            &#125;\n            Else\n            &#123;\n                Store (B1B2 (FCB0, FCB1), Local1)\n            &#125;\n\n            Store (Local1, Index (Arg1, 0x02))\n            Or (Arg0, 0x02, HIID)\n            If (Local7)\n            &#123;\n                Multiply (B1B2 (DCB0, DCB1), 0x0A, Local0)\n            &#125;\n            Else\n            &#123;\n                Store (B1B2 (DCB0, DCB1), Local0)\n            &#125;\n\n            Store (Local0, Index (Arg1, One))\n            Divide (Local1, 0x14, Local2, Index (Arg1, 0x05))\n            If (Local7)\n            &#123;\n                Store (0xC8, Index (Arg1, 0x06))\n            &#125;\n            ElseIf (B1B2 (DVB0, DVB1))\n            &#123;\n                Divide (0x00030D40, B1B2 (DVB0, DVB1), Local2, Index (Arg1, 0x06))\n            &#125;\n            Else\n            &#123;\n                Store (Zero, Index (Arg1, 0x06))\n            &#125;\n\n            Store (B1B2 (DVB0, DVB1), Index (Arg1, 0x04))\n            Store (B1B2 (SNB0, SNB1), Local0)\n            Name (SERN, Buffer (0x06)\n            &#123;\n                &quot;     &quot;\n            &#125;)\n            Store (0x04, Local2)\n            While (Local0)\n            &#123;\n                Divide (Local0, 0x0A, Local1, Local0)\n                Add (Local1, 0x30, Index (SERN, Local2))\n                Decrement (Local2)\n            &#125;\n\n            Store (SERN, Index (Arg1, 0x0A))\n            Or (Arg0, 0x06, HIID)\n            Store (RECB (0xA0, 0x80), Index (Arg1, 0x09))\n            Or (Arg0, 0x04, HIID)\n            Name (BTYP, Buffer (0x05)\n            &#123;\n                 0x00, 0x00, 0x00, 0x00, 0x00                   \n            &#125;)\n            Store (B1B4 (CHB0, CHB1, CHB2, CHB3), BTYP)\n            Store (BTYP, Index (Arg1, 0x0B))\n            Or (Arg0, 0x05, HIID)\n            Store (RECB (0xA0, 0x80), Index (Arg1, 0x0C))\n        &#125;\n        Else\n        &#123;\n            Store (0xFFFFFFFF, Index (Arg1, One))\n            Store (Zero, Index (Arg1, 0x05))\n            Store (Zero, Index (Arg1, 0x06))\n            Store (0xFFFFFFFF, Index (Arg1, 0x02))\n        &#125;\n\n        Release (BATM)\n        Return (Arg1)\n    &#125;\n    Else\n    &#123;\n        Return (XBIF (Arg0, Arg1, Arg2))\n    &#125;\n&#125;</code></pre>\n<p>我们发现，我将GBIF在Else中重命名为了XBIF，这需要与后面config里添加重命名对应。<br>那么，你们可能会有疑问，这个Arg0这些是这么来的？<br>这个需要观察：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">Method (GBIF, 3, NotSerialized)</code></pre>\n<p>就是中间这个数字得来的，3的话就是在XBIF后面的括号里填写，Arg0， Arg1， Arg2。<br>是多少，你就从Arg0开始往后一个个按顺序加。0就不填，留空。</p>\n<p>添加完了这些后，你再编译，发现报错了，然后一样，补充引用声明。<br>如，</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">External (_SB.PCI0.LPC.EC.XBIF, MethodObj)</code></pre>\n<p>这样就可以了。</p>\n<h1 id=\"重命名与Mutex检查\"><a href=\"#重命名与Mutex检查\" class=\"headerlink\" title=\"重命名与Mutex检查\"></a>重命名与Mutex检查</h1><p>最后，我们来进行重命名和Mutex检查<br>比如GBIF，我们来重命名为XBIF，这样就不会与ACPI中的GBIF冲突了<br>规则如下：<br><code>Comment：BAT GBIF to XBIF</code><br>利用Hackintool，将GBIF转换为16进制为：47424946<br>我们再补上两位，这两位就需要看Method了</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">Method (GBIF, 3, NotSerialized)</code></pre>\n<p>NotSerialized代表0，Serialized代表8<br>我们将其相加，中间的数字+N或S<br>GBIF就是：3+0=3，3转换为16进制就是3<br>那么最后的两位就是03</p>\n<p>XBIF的16进制为：58424946</p>\n<p>完整的如下：<br><code>Comment：BAT GBIF to XBIF</code><br><code>Find：47424946 03</code><br><code>Replace：58424946 03</code></p>\n<p>GBST的就是：<br><code>Method (GBST, 4, NotSerialized)</code></p>\n<p><code>Comment：BAT GBST to XBST</code><br><code>Find：47425354 04</code><br><code>Replace：58425354 04</code></p>\n<p>把这些重命名加到Config里。</p>\n<p>你需要检查Mutex，确保他们全部为0 在当前使用的DSDT文件里搜索Mutex，看出现的几个变量是否为0，目前所知道的绝大多数机器的ACPI Mutex都是默认置0的，但是对于一些联想机器，它们往往有几个Mutex初始值并不是0，这里我们利用ACPI二进制更名的方法实现置0</p>\n<p>以Mutex (BATM, 0x07)为例，先转换BATM为十六进制代码，得到 42 41 54 4D</p>\n<p>在前后加上完整定义的十六进制代码，01代表Mutex，07则代表默认值，最终得到 01 42 41 54 4D 07</p>\n<p>我们的目的是使Mutex对象置0，所以config的更名应填</p>\n<p><code>Comment Set Mutex BATM, 0x07 to 0x0</code><br><code>Find 01 42 41 54 4D 07</code><br><code>Repalce 01 42 41 54 4D 00</code><br>其它Mutex对象按照同样的方法处理即可</p>\n<p>这样下来你的电池热补丁就基本制作完毕了，对于双电池系统的电池（实际只有一块电池的），我们需要禁用其中一个。</p>\n<h1 id=\"双电池系统，屏蔽其中一个\"><a href=\"#双电池系统，屏蔽其中一个\" class=\"headerlink\" title=\"双电池系统，屏蔽其中一个\"></a>双电池系统，屏蔽其中一个</h1><p>比如，你的DSDT中有BAT0或BAT1两个电池设备，但你实际只在用其中一个。那么，你先看看另一个是否开启，如果另一个也是开启的，你需要屏蔽它。</p>\n<p>参考我给的<strong>SSDT-BAT0-Disable-X260.aml</strong></p>\n<p><img src=\"https://i.loli.net/2021/05/02/IwkrJstTnhENlQ8.png\"></p>\n<p>将DefinitionBlock框出来的位置，改成自己的，同时修改External和Scope为自己所要屏蔽的电池设备的路径。</p>\n<p>然后保存即可。</p>\n<p>然后我们要对所屏蔽电池设备下的_STA进行更名：</p>\n<p><strong>CLOVER</strong>：处理比较简单，将所需屏蔽的电池设备，转换为16进制，比如BAT1（42415430）<br><code>Comment：BAT _STA to XSTA in BAT1</code><br><code>Find：5F535441</code><br><code>Replace：58535441</code><br><code>TgtBridge：42415431</code></p>\n<p><strong>OC</strong>：OpenCore因为没有TgtBridge，因此处理比较麻烦<br>1.选择使用skip，count：Skip为跳过，就看你所要更改的_STA上有几个一样的_STA就跳过几个，count是替换次数，填1次即可<br><code>Comment：BAT _STA to XSTA in BAT1</code><br><code>Find：5F535441</code><br><code>Replace：58535441</code><br><code>Skip:（填跳过的次数）</code><br><code>Count：1</code></p>\n<p>到这里，你已经做好一个电池热补丁和屏蔽补丁了，然后再加上ACPIBatteryManager.kext或者SMCBatteryManager.kext，不出问题，你就可以看到你可爱的电池图标了！<img src=\"https://i.loli.net/2021/05/02/xmjbo7Z3W4zGYeS.png\"><br><img src=\"https://i.loli.net/2021/05/02/kCFX1AwrJWH9lsa.png\"></p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>加入博主的Hackintosh交流群：<code>679838716</code></p>\n","feature":true,"text":"前言在有了OpenCore的引导后，已经不在推荐使用DSDT了，况且，现在也是主要推广热补丁（HotPatch），热补丁具有比DSDT更好的灵活性，于是便开始写这篇文章了。 准备步骤首先，我们需要下载我提供的电池热补丁的样本（SSDT-BATT.dsl)。同时，我还准备了联想X2...","link":"","photos":[],"count_time":{"symbolsCount":"20k","symbolsTime":"18 mins."},"categories":[{"name":"技术","slug":"技术","count":10,"path":"api/categories/技术.json"}],"tags":[{"name":"黑苹果","slug":"黑苹果","count":7,"path":"api/tags/黑苹果.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%87%86%E5%A4%87%E6%AD%A5%E9%AA%A4\"><span class=\"toc-text\">准备步骤</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%88%9D%E6%AD%A5%E5%8A%A8%E4%BD%9C\"><span class=\"toc-text\">初步动作</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#16%E4%BD%8D%E5%92%8C32%E4%BD%8D%E7%9A%84%E5%A4%84%E7%90%86\"><span class=\"toc-text\">16位和32位的处理</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#32%E4%BD%8D%E4%BB%A5%E4%B8%8A%E5%AD%97%E8%8A%82%E7%9A%84%E5%A4%84%E7%90%86\"><span class=\"toc-text\">32位以上字节的处理</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%8E%92%E9%94%99%EF%BC%8C%E8%A1%A5%E5%85%85%E5%BC%95%E7%94%A8%E5%A3%B0%E6%98%8E\"><span class=\"toc-text\">排错，补充引用声明</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%B7%BB%E5%8A%A0if%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5\"><span class=\"toc-text\">添加if判断语句</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%87%8D%E5%91%BD%E5%90%8D%E4%B8%8EMutex%E6%A3%80%E6%9F%A5\"><span class=\"toc-text\">重命名与Mutex检查</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8F%8C%E7%94%B5%E6%B1%A0%E7%B3%BB%E7%BB%9F%EF%BC%8C%E5%B1%8F%E8%94%BD%E5%85%B6%E4%B8%AD%E4%B8%80%E4%B8%AA\"><span class=\"toc-text\">双电池系统，屏蔽其中一个</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%BB%93%E8%AF%AD\"><span class=\"toc-text\">结语</span></a></li></ol>","author":{"name":"神楽小白(GZ小白)的部落阁","slug":"blog-author","avatar":"https://i.loli.net/2021/05/15/QdcDz8P721AfEMR.jpg","link":"/","description":"这是一个正常的人(确信)!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":{"icon":"/svg/github.svg","link":"https://github.com/GZXiaoBai"},"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/355276854"}}}},"mapped":true,"prev_post":{"title":"用热补丁修理你的触摸板（TouchPad-Hotpatch）","uid":"4f0dd3439efb7ba90d574e3fcd61c5dd","slug":"用热补丁修理你的触摸板（TouchPad-Hotpatch）","date":"2020-05-17T01:30:19.000Z","updated":"2021-06-04T10:14:50.536Z","comments":true,"path":"api/articles/用热补丁修理你的触摸板（TouchPad-Hotpatch）.json","keywords":null,"cover":"https://i.loli.net/2021/05/02/FZVbE4tw1kqgOez.jpg","text":"前言当你的触摸板无法正常工作时，或者一点也不工作时，那你可能就需要修改ACPI来修补修补你的触摸板来，使其能够正常工作。毕竟一台笔记本电脑，用不了触摸板实在是太难受了。（如果你有钱买妙控板，那就另当别论了） 确定设备路径1.进入Windows系统，打开设备管理器，找到人体输入学设...","link":"","photos":[],"count_time":{"symbolsCount":"30k","symbolsTime":"27 mins."},"categories":[{"name":"技术","slug":"技术","count":10,"path":"api/categories/技术.json"}],"tags":[{"name":"黑苹果","slug":"黑苹果","count":7,"path":"api/tags/黑苹果.json"}],"author":{"name":"神楽小白(GZ小白)的部落阁","slug":"blog-author","avatar":"https://i.loli.net/2021/05/15/QdcDz8P721AfEMR.jpg","link":"/","description":"这是一个正常的人(确信)!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":{"icon":"/svg/github.svg","link":"https://github.com/GZXiaoBai"},"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/355276854"}}}},"feature":true},"next_post":{"title":"利用GUPC以热补丁定制USB端口","uid":"8988c31c9c6b01303dadfca403bf5e1f","slug":"利用GUPC以热补丁定制USB端口","date":"2021-05-09T06:30:18.000Z","updated":"2021-06-04T10:13:48.334Z","comments":true,"path":"api/articles/利用GUPC以热补丁定制USB端口.json","keywords":null,"cover":"https://i.loli.net/2021/05/22/qZOCU6QIdDzblTL.jpg","text":"前言虽然之前就有用热补丁定制USB端口的方法，但那个方法需要搭配USBAllinject.kext使用，在受到Github中一个issue的启发后，我们发现，可以利用ACPI中的GUPC实现USB端口的热补丁定制。最后，通过咨询了哞大相关问题，发此贴，提供方法。 Github的i...","link":"","photos":[],"count_time":{"symbolsCount":"4.6k","symbolsTime":"4 mins."},"categories":[{"name":"技术","slug":"技术","count":10,"path":"api/categories/技术.json"}],"tags":[{"name":"黑苹果","slug":"黑苹果","count":7,"path":"api/tags/黑苹果.json"}],"author":{"name":"神楽小白(GZ小白)的部落阁","slug":"blog-author","avatar":"https://i.loli.net/2021/05/15/QdcDz8P721AfEMR.jpg","link":"/","description":"这是一个正常的人(确信)!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":{"icon":"/svg/github.svg","link":"https://github.com/GZXiaoBai"},"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/355276854"}}}}}}